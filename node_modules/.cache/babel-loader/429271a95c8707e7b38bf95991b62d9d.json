{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nvar _classCallCheck = require(\"/Users/maidat/Desktop/team-lq/persol-lqmb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/maidat/Desktop/team-lq/persol-lqmb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar INITIAL_BACKOFF_MS = 1000;\nvar BACKOFF_MULTIPLIER = 1.6;\nvar MAX_BACKOFF_MS = 120000;\nvar BACKOFF_JITTER = 0.2;\n/**\n * Get a number uniformly at random in the range [min, max)\n * @param min\n * @param max\n */\n\nfunction uniformRandom(min, max) {\n  return Math.random() * (max - min) + min;\n}\n\nvar BackoffTimeout =\n/*#__PURE__*/\nfunction () {\n  function BackoffTimeout(callback, options) {\n    _classCallCheck(this, BackoffTimeout);\n\n    this.callback = callback;\n    this.initialDelay = INITIAL_BACKOFF_MS;\n    this.multiplier = BACKOFF_MULTIPLIER;\n    this.maxDelay = MAX_BACKOFF_MS;\n    this.jitter = BACKOFF_JITTER;\n    this.running = false;\n\n    if (options) {\n      if (options.initialDelay) {\n        this.initialDelay = options.initialDelay;\n      }\n\n      if (options.multiplier) {\n        this.multiplier = options.multiplier;\n      }\n\n      if (options.jitter) {\n        this.jitter = options.jitter;\n      }\n\n      if (options.maxDelay) {\n        this.maxDelay = options.maxDelay;\n      }\n    }\n\n    this.nextDelay = this.initialDelay;\n    this.timerId = setTimeout(function () {}, 0);\n    clearTimeout(this.timerId);\n  }\n  /**\n   * Call the callback after the current amount of delay time\n   */\n\n\n  _createClass(BackoffTimeout, [{\n    key: \"runOnce\",\n    value: function runOnce() {\n      var _this = this;\n\n      this.running = true;\n      this.timerId = setTimeout(function () {\n        _this.callback();\n\n        _this.running = false;\n      }, this.nextDelay);\n      var nextBackoff = Math.min(this.nextDelay * this.multiplier, this.maxDelay);\n      var jitterMagnitude = nextBackoff * this.jitter;\n      this.nextDelay = nextBackoff + uniformRandom(-jitterMagnitude, jitterMagnitude);\n    }\n    /**\n     * Stop the timer. The callback will not be called until `runOnce` is called\n     * again.\n     */\n\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      clearTimeout(this.timerId);\n      this.running = false;\n    }\n    /**\n     * Reset the delay time to its initial value.\n     */\n\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this.nextDelay = this.initialDelay;\n    }\n  }, {\n    key: \"isRunning\",\n    value: function isRunning() {\n      return this.running;\n    }\n  }]);\n\n  return BackoffTimeout;\n}();\n\nexports.BackoffTimeout = BackoffTimeout;","map":null,"metadata":{},"sourceType":"script"}