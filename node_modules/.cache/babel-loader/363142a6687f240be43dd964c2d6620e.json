{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar _slicedToArray = require(\"/Users/maidat/Desktop/team-lq/persol-lqmb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _classCallCheck = require(\"/Users/maidat/Desktop/team-lq/persol-lqmb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/maidat/Desktop/team-lq/persol-lqmb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar resolver_1 = require(\"./resolver\");\n\nvar dns = require(\"dns\");\n\nvar semver = require(\"semver\");\n\nvar util = require(\"util\");\n\nvar service_config_1 = require(\"./service-config\");\n\nvar constants_1 = require(\"./constants\");\n\nvar metadata_1 = require(\"./metadata\");\n\nvar logging = require(\"./logging\");\n\nvar constants_2 = require(\"./constants\");\n\nvar TRACER_NAME = 'dns_resolver';\n\nfunction trace(text) {\n  logging.trace(constants_2.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\n/* These regular expressions match IP addresses with optional ports in different\n * formats. In each case, capture group 1 contains the address, and capture\n * group 2 contains the port number, if present */\n\n/**\n * Matches 4 groups of up to 3 digits each, separated by periods, optionally\n * followed by a colon and a number.\n */\n\n\nvar IPV4_REGEX = /^(\\d{1,3}(?:\\.\\d{1,3}){3})(?::(\\d+))?$/;\n/**\n * Matches any number of groups of up to 4 hex digits (case insensitive)\n * separated by 1 or more colons. This variant does not match a port number.\n */\n\nvar IPV6_REGEX = /^([0-9a-f]{0,4}(?::{1,2}[0-9a-f]{0,4})+)$/i;\n/**\n * Matches the same as the IPv6_REGEX, surrounded by square brackets, and\n * optionally followed by a colon and a number.\n */\n\nvar IPV6_BRACKET_REGEX = /^\\[([0-9a-f]{0,4}(?::{1,2}[0-9a-f]{0,4})+)\\](?::(\\d+))?$/i;\n/**\n * Matches `[dns:][//authority/]host[:port]`, where `authority` and `host` are\n * both arbitrary sequences of dot-separated strings of alphanumeric characters\n * and `port` is a sequence of digits. Group 1 contains the hostname and group\n * 2 contains the port number if provided.\n */\n\nvar DNS_REGEX = /^(?:dns:)?(?:\\/\\/(?:[a-zA-Z0-9-]+\\.?)+\\/)?((?:[a-zA-Z0-9-]+\\.?)+)(?::(\\d+))?$/;\n/**\n * The default TCP port to connect to if not explicitly specified in the target.\n */\n\nvar DEFAULT_PORT = '443';\n/**\n * The range of Node versions in which the Node issue\n * https://github.com/nodejs/node/issues/28216 has been fixed. In other\n * versions, IPv6 literal addresses cannot be used to establish HTTP/2\n * connections.\n */\n\nvar IPV6_SUPPORT_RANGE = '>= 12.6';\n/**\n * Get a promise that always resolves with either the result of the function\n * or the error if it failed.\n * @param fn\n */\n\nfunction resolvePromisify(fn) {\n  return function (arg) {\n    return new Promise(function (resolve, reject) {\n      fn(arg, function (error, result) {\n        if (error) {\n          resolve(error);\n        } else {\n          resolve(result);\n        }\n      });\n    });\n  };\n}\n\nvar resolveTxtPromise = resolvePromisify(dns.resolveTxt);\nvar dnsLookupPromise = util.promisify(dns.lookup);\n/**\n * Attempt to parse a target string as an IP address\n * @param target\n * @return An \"IP:port\" string in an array if parsing was successful, `null` otherwise\n */\n\nfunction parseIP(target) {\n  /* These three regular expressions are all mutually exclusive, so we just\n   * want the first one that matches the target string, if any do. */\n  var ipv4Match = IPV4_REGEX.exec(target);\n  var match = ipv4Match || IPV6_REGEX.exec(target) || IPV6_BRACKET_REGEX.exec(target);\n\n  if (match === null) {\n    return null;\n  } // ipv6 addresses should be bracketed\n\n\n  var addr = ipv4Match ? match[1] : \"[\".concat(match[1], \"]\");\n  var port;\n\n  if (match[2]) {\n    port = match[2];\n  } else {\n    port = DEFAULT_PORT;\n  }\n\n  return [\"\".concat(addr, \":\").concat(port)];\n}\n/**\n * Merge any number of arrays into a single alternating array\n * @param arrays\n */\n\n\nfunction mergeArrays() {\n  var result = [];\n\n  for (var _len = arguments.length, arrays = new Array(_len), _key = 0; _key < _len; _key++) {\n    arrays[_key] = arguments[_key];\n  }\n\n  for (var i = 0; i < Math.max.apply(null, arrays.map(function (array) {\n    return array.length;\n  })); i++) {\n    for (var _i = 0, _arrays = arrays; _i < _arrays.length; _i++) {\n      var array = _arrays[_i];\n\n      if (i < array.length) {\n        result.push(array[i]);\n      }\n    }\n  }\n\n  return result;\n}\n/**\n * Resolver implementation that handles DNS names and IP addresses.\n */\n\n\nvar DnsResolver =\n/*#__PURE__*/\nfunction () {\n  function DnsResolver(target, listener) {\n    _classCallCheck(this, DnsResolver);\n\n    this.target = target;\n    this.listener = listener;\n    /* The promise results here contain, in order, the A record, the AAAA record,\n     * and either the TXT record or an error if TXT resolution failed */\n\n    this.pendingResultPromise = null;\n    trace('Resolver constructed for target ' + target);\n    this.ipResult = parseIP(target);\n    var dnsMatch = DNS_REGEX.exec(target);\n\n    if (dnsMatch === null) {\n      this.dnsHostname = null;\n      this.port = null;\n    } else {\n      this.dnsHostname = dnsMatch[1];\n\n      if (dnsMatch[2]) {\n        this.port = dnsMatch[2];\n      } else {\n        this.port = DEFAULT_PORT;\n      }\n    }\n\n    this.percentage = Math.random() * 100;\n    this.defaultResolutionError = {\n      code: constants_1.Status.UNAVAILABLE,\n      details: \"Name resolution failed for target \".concat(this.target),\n      metadata: new metadata_1.Metadata()\n    };\n  }\n  /**\n   * If the target is an IP address, just provide that address as a result.\n   * Otherwise, initiate A, AAAA, and TXT\n   */\n\n\n  _createClass(DnsResolver, [{\n    key: \"startResolution\",\n    value: function startResolution() {\n      var _this = this;\n\n      if (this.ipResult !== null) {\n        trace('Returning IP address for target ' + this.target);\n        setImmediate(function () {\n          _this.listener.onSuccessfulResolution(_this.ipResult, null, null);\n        });\n        return;\n      }\n\n      if (this.dnsHostname !== null) {\n        var hostname = this.dnsHostname;\n        /* We lookup both address families here and then split them up later\n         * because when looking up a single family, dns.lookup outputs an error\n         * if the name exists but there are no records for that family, and that\n         * error is indistinguishable from other kinds of errors */\n\n        var addressResult = dnsLookupPromise(hostname, {\n          all: true\n        });\n        /* We handle the TXT query promise differently than the others because\n         * the name resolution attempt as a whole is a success even if the TXT\n         * lookup fails */\n\n        var txtResult = resolveTxtPromise(hostname);\n        this.pendingResultPromise = Promise.all([addressResult, txtResult]);\n        this.pendingResultPromise.then(function (_ref) {\n          var _ref2 = _slicedToArray(_ref, 2),\n              addressList = _ref2[0],\n              txtRecord = _ref2[1];\n\n          _this.pendingResultPromise = null;\n          var ip4Addresses = addressList.filter(function (addr) {\n            return addr.family === 4;\n          }).map(function (addr) {\n            return \"\".concat(addr.address, \":\").concat(_this.port);\n          });\n          var ip6Addresses;\n\n          if (semver.satisfies(process.version, IPV6_SUPPORT_RANGE)) {\n            ip6Addresses = addressList.filter(function (addr) {\n              return addr.family === 6;\n            }).map(function (addr) {\n              return \"[\".concat(addr.address, \"]:\").concat(_this.port);\n            });\n          } else {\n            ip6Addresses = [];\n          }\n\n          var allAddresses = mergeArrays(ip4Addresses, ip6Addresses);\n          trace('Resolved addresses for target ' + _this.target + ': ' + allAddresses);\n\n          if (allAddresses.length === 0) {\n            _this.listener.onError(_this.defaultResolutionError);\n\n            return;\n          }\n\n          var serviceConfig = null;\n          var serviceConfigError = null;\n\n          if (txtRecord instanceof Error) {\n            serviceConfigError = {\n              code: constants_1.Status.UNAVAILABLE,\n              details: 'TXT query failed',\n              metadata: new metadata_1.Metadata()\n            };\n          } else {\n            try {\n              serviceConfig = service_config_1.extractAndSelectServiceConfig(txtRecord, _this.percentage);\n            } catch (err) {\n              serviceConfigError = {\n                code: constants_1.Status.UNAVAILABLE,\n                details: 'Parsing service config failed',\n                metadata: new metadata_1.Metadata()\n              };\n            }\n          }\n\n          _this.listener.onSuccessfulResolution(allAddresses, serviceConfig, serviceConfigError);\n        }, function (err) {\n          trace('Resolution error for target ' + _this.target + ': ' + err.message);\n          _this.pendingResultPromise = null;\n\n          _this.listener.onError(_this.defaultResolutionError);\n        });\n      }\n    }\n  }, {\n    key: \"updateResolution\",\n    value: function updateResolution() {\n      trace('Resolution update requested for target ' + this.target);\n\n      if (this.pendingResultPromise === null) {\n        this.startResolution();\n      }\n    }\n    /**\n     * Get the default authority for the given target. For IP targets, that is\n     * the IP address. For DNS targets, it is the hostname.\n     * @param target\n     */\n\n  }], [{\n    key: \"getDefaultAuthority\",\n    value: function getDefaultAuthority(target) {\n      var ipMatch = IPV4_REGEX.exec(target) || IPV6_REGEX.exec(target) || IPV6_BRACKET_REGEX.exec(target);\n\n      if (ipMatch) {\n        return ipMatch[1];\n      }\n\n      var dnsMatch = DNS_REGEX.exec(target);\n\n      if (dnsMatch) {\n        return dnsMatch[1];\n      }\n\n      throw new Error(\"Failed to parse target \".concat(target));\n    }\n  }]);\n\n  return DnsResolver;\n}();\n/**\n * Set up the DNS resolver class by registering it as the handler for the\n * \"dns:\" prefix and as the default resolver.\n */\n\n\nfunction setup() {\n  resolver_1.registerResolver('dns:', DnsResolver);\n  resolver_1.registerDefaultResolver(DnsResolver);\n}\n\nexports.setup = setup;","map":null,"metadata":{},"sourceType":"script"}