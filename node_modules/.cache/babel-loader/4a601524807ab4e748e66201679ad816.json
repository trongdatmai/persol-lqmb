{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nvar _regeneratorRuntime = require(\"/Users/maidat/Desktop/team-lq/persol-lqmb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/maidat/Desktop/team-lq/persol-lqmb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _defineProperty = require(\"/Users/maidat/Desktop/team-lq/persol-lqmb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/defineProperty\");\n\nvar _classCallCheck = require(\"/Users/maidat/Desktop/team-lq/persol-lqmb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/maidat/Desktop/team-lq/persol-lqmb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar http2 = require(\"http2\");\n\nvar url_1 = require(\"url\");\n\nvar constants_1 = require(\"./constants\");\n\nvar metadata_1 = require(\"./metadata\");\n\nvar server_call_1 = require(\"./server-call\");\n\nfunction noop() {}\n\nvar unimplementedStatusResponse = {\n  code: constants_1.Status.UNIMPLEMENTED,\n  details: 'The server does not implement this method',\n  metadata: new metadata_1.Metadata()\n};\nvar defaultHandler = {\n  unary: function unary(call, callback) {\n    callback(unimplementedStatusResponse, null);\n  },\n  clientStream: function clientStream(call, callback) {\n    callback(unimplementedStatusResponse, null);\n  },\n  serverStream: function serverStream(call) {\n    call.emit('error', unimplementedStatusResponse);\n  },\n  bidi: function bidi(call) {\n    call.emit('error', unimplementedStatusResponse);\n  }\n}; // tslint:enable:no-any\n\nvar Server =\n/*#__PURE__*/\nfunction () {\n  function Server(options) {\n    _classCallCheck(this, Server);\n\n    this.http2Server = null;\n    this.handlers = new Map();\n    this.sessions = new Set();\n    this.started = false;\n    this.options = options !== null && options !== void 0 ? options : {};\n  }\n\n  _createClass(Server, [{\n    key: \"addProtoService\",\n    value: function addProtoService() {\n      throw new Error('Not implemented. Use addService() instead');\n    }\n  }, {\n    key: \"addService\",\n    value: function addService(service, implementation) {\n      var _this = this;\n\n      if (this.started === true) {\n        throw new Error(\"Can't add a service to a started server.\");\n      }\n\n      if (service === null || typeof service !== 'object' || implementation === null || typeof implementation !== 'object') {\n        throw new Error('addService() requires two objects as arguments');\n      }\n\n      var serviceKeys = Object.keys(service);\n\n      if (serviceKeys.length === 0) {\n        throw new Error('Cannot add an empty service to a server');\n      }\n\n      serviceKeys.forEach(function (name) {\n        var attrs = service[name];\n        var methodType;\n\n        if (attrs.requestStream) {\n          if (attrs.responseStream) {\n            methodType = 'bidi';\n          } else {\n            methodType = 'clientStream';\n          }\n        } else {\n          if (attrs.responseStream) {\n            methodType = 'serverStream';\n          } else {\n            methodType = 'unary';\n          }\n        }\n\n        var implFn = implementation[name];\n        var impl;\n\n        if (implFn === undefined && typeof attrs.originalName === 'string') {\n          implFn = implementation[attrs.originalName];\n        }\n\n        if (implFn !== undefined) {\n          impl = implFn.bind(implementation);\n        } else {\n          impl = defaultHandler[methodType];\n        }\n\n        var success = _this.register(attrs.path, impl, attrs.responseSerialize, attrs.requestDeserialize, methodType);\n\n        if (success === false) {\n          throw new Error(\"Method handler for \".concat(attrs.path, \" already provided.\"));\n        }\n      });\n    }\n  }, {\n    key: \"bind\",\n    value: function bind(port, creds) {\n      throw new Error('Not implemented. Use bindAsync() instead');\n    }\n  }, {\n    key: \"bindAsync\",\n    value: function bindAsync(port, creds, callback) {\n      var _this2 = this;\n\n      if (this.started === true) {\n        throw new Error('server is already started');\n      }\n\n      if (typeof port !== 'string') {\n        throw new TypeError('port must be a string');\n      }\n\n      if (creds === null || typeof creds !== 'object') {\n        throw new TypeError('creds must be an object');\n      }\n\n      if (typeof callback !== 'function') {\n        throw new TypeError('callback must be a function');\n      }\n\n      var url = new url_1.URL(\"http://\".concat(port));\n      var options = {\n        host: url.hostname,\n        port: +url.port\n      };\n      var serverOptions = {};\n\n      if ('grpc.max_concurrent_streams' in this.options) {\n        serverOptions.settings = {\n          maxConcurrentStreams: this.options['grpc.max_concurrent_streams']\n        };\n      }\n\n      if (creds._isSecure()) {\n        var secureServerOptions = Object.assign(serverOptions, creds._getSettings());\n        this.http2Server = http2.createSecureServer(secureServerOptions);\n      } else {\n        this.http2Server = http2.createServer(serverOptions);\n      }\n\n      this.http2Server.setTimeout(0, noop);\n\n      this._setupHandlers();\n\n      function onError(err) {\n        callback(err, -1);\n      }\n\n      this.http2Server.once('error', onError);\n      this.http2Server.listen(options, function () {\n        var server = _this2.http2Server;\n        var port = server.address().port;\n        server.removeListener('error', onError);\n        callback(null, port);\n      });\n    }\n  }, {\n    key: \"forceShutdown\",\n    value: function forceShutdown() {\n      // Close the server if it is still running.\n      if (this.http2Server && this.http2Server.listening) {\n        this.http2Server.close();\n      }\n\n      this.started = false; // Always destroy any available sessions. It's possible that one or more\n      // tryShutdown() calls are in progress. Don't wait on them to finish.\n\n      this.sessions.forEach(function (session) {\n        // Cast NGHTTP2_CANCEL to any because TypeScript doesn't seem to\n        // recognize destroy(code) as a valid signature.\n        // tslint:disable-next-line:no-any\n        session.destroy(http2.constants.NGHTTP2_CANCEL);\n      });\n      this.sessions.clear();\n    }\n  }, {\n    key: \"register\",\n    value: function register(name, handler, serialize, deserialize, type) {\n      if (this.handlers.has(name)) {\n        return false;\n      }\n\n      this.handlers.set(name, {\n        func: handler,\n        serialize: serialize,\n        deserialize: deserialize,\n        type: type\n      });\n      return true;\n    }\n  }, {\n    key: \"start\",\n    value: function start() {\n      if (this.http2Server === null || this.http2Server.listening !== true) {\n        throw new Error('server must be bound in order to start');\n      }\n\n      if (this.started === true) {\n        throw new Error('server is already started');\n      }\n\n      this.started = true;\n    }\n  }, {\n    key: \"tryShutdown\",\n    value: function tryShutdown(callback) {\n      var pendingChecks = 0;\n\n      function maybeCallback() {\n        pendingChecks--;\n\n        if (pendingChecks === 0) {\n          callback();\n        }\n      } // Close the server if necessary.\n\n\n      this.started = false;\n\n      if (this.http2Server && this.http2Server.listening) {\n        pendingChecks++;\n        this.http2Server.close(maybeCallback);\n      } // If any sessions are active, close them gracefully.\n\n\n      pendingChecks += this.sessions.size;\n      this.sessions.forEach(function (session) {\n        session.close(maybeCallback);\n      }); // If the server is closed and there are no active sessions, just call back.\n\n      if (pendingChecks === 0) {\n        callback();\n      }\n    }\n  }, {\n    key: \"addHttp2Port\",\n    value: function addHttp2Port() {\n      throw new Error('Not yet implemented');\n    }\n  }, {\n    key: \"_setupHandlers\",\n    value: function _setupHandlers() {\n      var _this3 = this;\n\n      if (this.http2Server === null) {\n        return;\n      }\n\n      this.http2Server.on('stream', function (stream, headers) {\n        var contentType = headers[http2.constants.HTTP2_HEADER_CONTENT_TYPE];\n\n        if (typeof contentType !== 'string' || !contentType.startsWith('application/grpc')) {\n          stream.respond(_defineProperty({}, http2.constants.HTTP2_HEADER_STATUS, http2.constants.HTTP_STATUS_UNSUPPORTED_MEDIA_TYPE), {\n            endStream: true\n          });\n          return;\n        }\n\n        try {\n          var path = headers[http2.constants.HTTP2_HEADER_PATH];\n\n          var handler = _this3.handlers.get(path);\n\n          if (handler === undefined) {\n            throw unimplementedStatusResponse;\n          }\n\n          var call = new server_call_1.Http2ServerCallStream(stream, handler);\n          var metadata = call.receiveMetadata(headers);\n\n          switch (handler.type) {\n            case 'unary':\n              handleUnary(call, handler, metadata);\n              break;\n\n            case 'clientStream':\n              handleClientStreaming(call, handler, metadata);\n              break;\n\n            case 'serverStream':\n              handleServerStreaming(call, handler, metadata);\n              break;\n\n            case 'bidi':\n              handleBidiStreaming(call, handler, metadata);\n              break;\n\n            default:\n              throw new Error(\"Unknown handler type: \".concat(handler.type));\n          }\n        } catch (err) {\n          var _call = new server_call_1.Http2ServerCallStream(stream, null);\n\n          if (err.code === undefined) {\n            err.code = constants_1.Status.INTERNAL;\n          }\n\n          _call.sendError(err);\n        }\n      });\n      this.http2Server.on('session', function (session) {\n        if (!_this3.started) {\n          session.destroy();\n          return;\n        }\n\n        _this3.sessions.add(session);\n      });\n    }\n  }]);\n\n  return Server;\n}();\n\nexports.Server = Server;\n\nfunction handleUnary(_x, _x2, _x3) {\n  return _handleUnary.apply(this, arguments);\n}\n\nfunction _handleUnary() {\n  _handleUnary = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee(call, handler, metadata) {\n    var emitter, request;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            emitter = new server_call_1.ServerUnaryCallImpl(call, metadata);\n            _context.next = 3;\n            return call.receiveUnaryMessage();\n\n          case 3:\n            request = _context.sent;\n\n            if (!(request === undefined || call.cancelled)) {\n              _context.next = 6;\n              break;\n            }\n\n            return _context.abrupt(\"return\");\n\n          case 6:\n            emitter.request = request;\n            handler.func(emitter, function (err, value, trailer, flags) {\n              call.sendUnaryMessage(err, value, trailer, flags);\n            });\n\n          case 8:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _handleUnary.apply(this, arguments);\n}\n\nfunction handleClientStreaming(call, handler, metadata) {\n  var stream = new server_call_1.ServerReadableStreamImpl(call, metadata, handler.deserialize);\n\n  function respond(err, value, trailer, flags) {\n    stream.destroy();\n    call.sendUnaryMessage(err, value, trailer, flags);\n  }\n\n  if (call.cancelled) {\n    return;\n  }\n\n  stream.on('error', respond);\n  handler.func(stream, respond);\n}\n\nfunction handleServerStreaming(_x4, _x5, _x6) {\n  return _handleServerStreaming.apply(this, arguments);\n}\n\nfunction _handleServerStreaming() {\n  _handleServerStreaming = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee2(call, handler, metadata) {\n    var request, stream;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.next = 2;\n            return call.receiveUnaryMessage();\n\n          case 2:\n            request = _context2.sent;\n\n            if (!(request === undefined || call.cancelled)) {\n              _context2.next = 5;\n              break;\n            }\n\n            return _context2.abrupt(\"return\");\n\n          case 5:\n            stream = new server_call_1.ServerWritableStreamImpl(call, metadata, handler.serialize);\n            stream.request = request;\n            handler.func(stream);\n\n          case 8:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _handleServerStreaming.apply(this, arguments);\n}\n\nfunction handleBidiStreaming(call, handler, metadata) {\n  var stream = new server_call_1.ServerDuplexStreamImpl(call, metadata, handler.serialize, handler.deserialize);\n\n  if (call.cancelled) {\n    return;\n  }\n\n  handler.func(stream);\n}","map":null,"metadata":{},"sourceType":"script"}