{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nvar _regeneratorRuntime = require(\"/Users/maidat/Desktop/team-lq/persol-lqmb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/maidat/Desktop/team-lq/persol-lqmb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/maidat/Desktop/team-lq/persol-lqmb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/maidat/Desktop/team-lq/persol-lqmb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/Users/maidat/Desktop/team-lq/persol-lqmb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _assertThisInitialized = require(\"/Users/maidat/Desktop/team-lq/persol-lqmb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar _getPrototypeOf = require(\"/Users/maidat/Desktop/team-lq/persol-lqmb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _get = require(\"/Users/maidat/Desktop/team-lq/persol-lqmb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/get\");\n\nvar _inherits = require(\"/Users/maidat/Desktop/team-lq/persol-lqmb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar http2 = require(\"http2\");\n\nvar stream_1 = require(\"stream\");\n\nvar constants_1 = require(\"./constants\");\n\nvar metadata_1 = require(\"./metadata\");\n\nvar stream_decoder_1 = require(\"./stream-decoder\");\n\nvar logging = require(\"./logging\");\n\nvar constants_2 = require(\"./constants\");\n\nvar TRACER_NAME = 'call_stream';\nvar _http2$constants = http2.constants,\n    HTTP2_HEADER_STATUS = _http2$constants.HTTP2_HEADER_STATUS,\n    HTTP2_HEADER_CONTENT_TYPE = _http2$constants.HTTP2_HEADER_CONTENT_TYPE,\n    NGHTTP2_CANCEL = _http2$constants.NGHTTP2_CANCEL;\n\nvar Http2CallStream =\n/*#__PURE__*/\nfunction (_stream_1$Duplex) {\n  _inherits(Http2CallStream, _stream_1$Duplex);\n\n  function Http2CallStream(methodName, channel, options, filterStackFactory, channelCallCredentials, callNumber) {\n    var _this;\n\n    _classCallCheck(this, Http2CallStream);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Http2CallStream).call(this, {\n      objectMode: true\n    }));\n    _this.methodName = methodName;\n    _this.channel = channel;\n    _this.options = options;\n    _this.channelCallCredentials = channelCallCredentials;\n    _this.callNumber = callNumber;\n    _this.http2Stream = null;\n    _this.pendingRead = false;\n    _this.pendingWrite = null;\n    _this.pendingWriteCallback = null;\n    _this.pendingFinalCallback = null;\n    _this.decoder = new stream_decoder_1.StreamDecoder();\n    _this.isReadFilterPending = false;\n    _this.canPush = false;\n    _this.unpushedReadMessages = [];\n    _this.unfilteredReadMessages = []; // Status code mapped from :status. To be used if grpc-status is not received\n\n    _this.mappedStatusCode = constants_1.Status.UNKNOWN; // Promise objects that are re-assigned to resolving promises when headers\n    // or trailers received. Processing headers/trailers is asynchronous, so we\n    // can use these objects to await their completion. This helps us establish\n    // order of precedence when obtaining the status of the call.\n\n    _this.handlingHeaders = Promise.resolve();\n    _this.handlingTrailers = Promise.resolve(); // This is populated (non-null) if and only if the call has ended\n\n    _this.finalStatus = null;\n    _this.subchannel = null;\n    _this.filterStack = filterStackFactory.createFilter(_assertThisInitialized(_this));\n    _this.credentials = channelCallCredentials;\n\n    _this.disconnectListener = function () {\n      _this.endCall({\n        code: constants_1.Status.UNAVAILABLE,\n        details: 'Connection dropped',\n        metadata: new metadata_1.Metadata()\n      });\n    };\n\n    return _this;\n  }\n\n  _createClass(Http2CallStream, [{\n    key: \"trace\",\n    value: function trace(text) {\n      logging.trace(constants_2.LogVerbosity.DEBUG, TRACER_NAME, '[' + this.callNumber + '] ' + text);\n    } // tslint:disable-next-line:no-any\n\n  }, {\n    key: \"push\",\n    value: function push(chunk, encoding) {\n      this.trace('pushing to reader message of length ' + (chunk instanceof Buffer ? chunk.length : null));\n      return _get(_getPrototypeOf(Http2CallStream.prototype), \"push\", this).call(this, chunk);\n    }\n    /**\n     * On first call, emits a 'status' event with the given StatusObject.\n     * Subsequent calls are no-ops.\n     * @param status The status of the call.\n     */\n\n  }, {\n    key: \"endCall\",\n    value: function endCall(status) {\n      var _this2 = this;\n\n      if (this.finalStatus === null) {\n        this.trace('ended with status: code=' + status.code + ' details=\"' + status.details + '\"');\n        this.finalStatus = status;\n        /* We do this asynchronously to ensure that no async function is in the\n         * call stack when we return control to the application. If an async\n         * function is in the call stack, any exception thrown by the application\n         * (or our tests) will bubble up and turn into promise rejection, which\n         * will result in an UnhandledPromiseRejectionWarning. Because that is\n         * a warning, the error will be effectively swallowed and execution will\n         * continue */\n\n        process.nextTick(function () {\n          _this2.emit('status', status);\n        });\n\n        if (this.subchannel) {\n          this.subchannel.callUnref();\n          this.subchannel.removeDisconnectListener(this.disconnectListener);\n        }\n      }\n    }\n  }, {\n    key: \"handleFilterError\",\n    value: function handleFilterError(error) {\n      this.cancelWithStatus(constants_1.Status.INTERNAL, error.message);\n    }\n  }, {\n    key: \"handleFilteredRead\",\n    value: function handleFilteredRead(message) {\n      /* If we the call has already ended, we don't want to do anything with\n       * this message. Dropping it on the floor is correct behavior */\n      if (this.finalStatus !== null) {\n        return;\n      }\n\n      this.isReadFilterPending = false;\n\n      if (this.canPush) {\n        if (!this.push(message)) {\n          this.canPush = false;\n          this.http2Stream.pause();\n        }\n      } else {\n        this.trace('unpushedReadMessages.push message of length ' + message.length);\n        this.unpushedReadMessages.push(message);\n      }\n\n      if (this.unfilteredReadMessages.length > 0) {\n        /* nextMessage is guaranteed not to be undefined because\n           unfilteredReadMessages is non-empty */\n        var nextMessage = this.unfilteredReadMessages.shift();\n        this.filterReceivedMessage(nextMessage);\n      }\n    }\n  }, {\n    key: \"filterReceivedMessage\",\n    value: function filterReceivedMessage(framedMessage) {\n      /* If we the call has already ended, we don't want to do anything with\n       * this message. Dropping it on the floor is correct behavior */\n      if (this.finalStatus !== null) {\n        return;\n      }\n\n      if (framedMessage === null) {\n        if (this.canPush) {\n          this.push(null);\n        } else {\n          this.unpushedReadMessages.push(null);\n        }\n\n        return;\n      }\n\n      this.trace('filterReceivedMessage of length ' + framedMessage.length);\n      this.isReadFilterPending = true;\n      this.filterStack.receiveMessage(Promise.resolve(framedMessage)).then(this.handleFilteredRead.bind(this), this.handleFilterError.bind(this));\n    }\n  }, {\n    key: \"tryPush\",\n    value: function tryPush(messageBytes) {\n      if (this.isReadFilterPending) {\n        this.trace('[' + this.callNumber + '] unfilteredReadMessages.push message of length ' + (messageBytes && messageBytes.length));\n        this.unfilteredReadMessages.push(messageBytes);\n      } else {\n        this.filterReceivedMessage(messageBytes);\n      }\n    }\n  }, {\n    key: \"handleTrailers\",\n    value: function handleTrailers(headers) {\n      var _this3 = this;\n\n      this.trace('received HTTP/2 trailing headers frame');\n      var code = this.mappedStatusCode;\n      var details = '';\n      var metadata;\n\n      try {\n        metadata = metadata_1.Metadata.fromHttp2Headers(headers);\n      } catch (e) {\n        metadata = new metadata_1.Metadata();\n      }\n\n      var status = {\n        code: code,\n        details: details,\n        metadata: metadata\n      };\n      this.handlingTrailers = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee() {\n        var finalStatus;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.prev = 0;\n                _context.next = 3;\n                return _this3.filterStack.receiveTrailers(Promise.resolve(status));\n\n              case 3:\n                finalStatus = _context.sent;\n                _context.next = 12;\n                break;\n\n              case 6:\n                _context.prev = 6;\n                _context.t0 = _context[\"catch\"](0);\n                _context.next = 10;\n                return _this3.handlingHeaders;\n\n              case 10:\n                // This is a no-op if the call was already ended when handling headers.\n                _this3.endCall({\n                  code: constants_1.Status.INTERNAL,\n                  details: 'Failed to process received status',\n                  metadata: new metadata_1.Metadata()\n                });\n\n                return _context.abrupt(\"return\");\n\n              case 12:\n                _context.next = 14;\n                return _this3.handlingHeaders;\n\n              case 14:\n                // This is a no-op if the call was already ended when handling headers.\n                _this3.endCall(finalStatus);\n\n              case 15:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, null, [[0, 6]]);\n      }))();\n    }\n  }, {\n    key: \"attachHttp2Stream\",\n    value: function attachHttp2Stream(stream, subchannel) {\n      var _this4 = this;\n\n      if (this.finalStatus !== null) {\n        stream.close(NGHTTP2_CANCEL);\n      } else {\n        this.trace('attachHttp2Stream from subchannel ' + subchannel.getAddress());\n        this.http2Stream = stream;\n        this.subchannel = subchannel;\n        subchannel.addDisconnectListener(this.disconnectListener);\n        subchannel.callRef();\n        stream.on('response', function (headers, flags) {\n          _this4.trace('received HTTP/2 headers frame');\n\n          switch (headers[':status']) {\n            // TODO(murgatroid99): handle 100 and 101\n            case 400:\n              _this4.mappedStatusCode = constants_1.Status.INTERNAL;\n              break;\n\n            case 401:\n              _this4.mappedStatusCode = constants_1.Status.UNAUTHENTICATED;\n              break;\n\n            case 403:\n              _this4.mappedStatusCode = constants_1.Status.PERMISSION_DENIED;\n              break;\n\n            case 404:\n              _this4.mappedStatusCode = constants_1.Status.UNIMPLEMENTED;\n              break;\n\n            case 429:\n            case 502:\n            case 503:\n            case 504:\n              _this4.mappedStatusCode = constants_1.Status.UNAVAILABLE;\n              break;\n\n            default:\n              _this4.mappedStatusCode = constants_1.Status.UNKNOWN;\n          }\n\n          if (flags & http2.constants.NGHTTP2_FLAG_END_STREAM) {\n            _this4.handleTrailers(headers);\n          } else {\n            var metadata;\n\n            try {\n              metadata = metadata_1.Metadata.fromHttp2Headers(headers);\n            } catch (error) {\n              _this4.endCall({\n                code: constants_1.Status.UNKNOWN,\n                details: error.message,\n                metadata: new metadata_1.Metadata()\n              });\n\n              return;\n            }\n\n            _this4.handlingHeaders = _this4.filterStack.receiveMetadata(Promise.resolve(metadata)).then(function (finalMetadata) {\n              _this4.emit('metadata', finalMetadata);\n            }).catch(function (error) {\n              _this4.destroyHttp2Stream();\n\n              _this4.endCall({\n                code: constants_1.Status.UNKNOWN,\n                details: error.message,\n                metadata: new metadata_1.Metadata()\n              });\n            });\n          }\n        });\n        stream.on('trailers', this.handleTrailers.bind(this));\n        stream.on('data', function (data) {\n          _this4.trace('receive HTTP/2 data frame of length ' + data.length);\n\n          var messages = _this4.decoder.write(data);\n\n          var _iteratorNormalCompletion = true;\n          var _didIteratorError = false;\n          var _iteratorError = undefined;\n\n          try {\n            for (var _iterator = messages[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n              var message = _step.value;\n\n              _this4.trace('parsed message of length ' + message.length);\n\n              _this4.tryPush(message);\n            }\n          } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion && _iterator.return != null) {\n                _iterator.return();\n              }\n            } finally {\n              if (_didIteratorError) {\n                throw _iteratorError;\n              }\n            }\n          }\n        });\n        stream.on('end', function () {\n          _this4.trace('received HTTP/2 end of data flag');\n\n          _this4.tryPush(null);\n        });\n        stream.on('close',\n        /*#__PURE__*/\n        _asyncToGenerator(\n        /*#__PURE__*/\n        _regeneratorRuntime.mark(function _callee2() {\n          var code, details;\n          return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n            while (1) {\n              switch (_context2.prev = _context2.next) {\n                case 0:\n                  _this4.trace('HTTP/2 stream closed with code ' + stream.rstCode);\n\n                  details = '';\n                  _context2.t0 = stream.rstCode;\n                  _context2.next = _context2.t0 === http2.constants.NGHTTP2_REFUSED_STREAM ? 5 : _context2.t0 === http2.constants.NGHTTP2_CANCEL ? 8 : _context2.t0 === http2.constants.NGHTTP2_ENHANCE_YOUR_CALM ? 11 : _context2.t0 === http2.constants.NGHTTP2_INADEQUATE_SECURITY ? 14 : 17;\n                  break;\n\n                case 5:\n                  code = constants_1.Status.UNAVAILABLE;\n                  details = 'Stream refused by server';\n                  return _context2.abrupt(\"break\", 18);\n\n                case 8:\n                  code = constants_1.Status.CANCELLED;\n                  details = 'Call cancelled';\n                  return _context2.abrupt(\"break\", 18);\n\n                case 11:\n                  code = constants_1.Status.RESOURCE_EXHAUSTED;\n                  details = 'Bandwidth exhausted';\n                  return _context2.abrupt(\"break\", 18);\n\n                case 14:\n                  code = constants_1.Status.PERMISSION_DENIED;\n                  details = 'Protocol not secure enough';\n                  return _context2.abrupt(\"break\", 18);\n\n                case 17:\n                  code = constants_1.Status.INTERNAL;\n\n                case 18:\n                  _context2.next = 20;\n                  return _this4.handlingTrailers;\n\n                case 20:\n                  // This is a no-op if trailers were received at all.\n                  // This is OK, because status codes emitted here correspond to more\n                  // catastrophic issues that prevent us from receiving trailers in the\n                  // first place.\n                  _this4.endCall({\n                    code: code,\n                    details: details,\n                    metadata: new metadata_1.Metadata()\n                  });\n\n                case 21:\n                case \"end\":\n                  return _context2.stop();\n              }\n            }\n          }, _callee2);\n        })));\n        stream.on('error', function (err) {\n          /* We need an error handler here to stop \"Uncaught Error\" exceptions\n           * from bubbling up. However, errors here should all correspond to\n           * \"close\" events, where we will handle the error more granularly */\n        });\n\n        if (!this.pendingRead) {\n          stream.pause();\n        }\n\n        if (this.pendingWrite) {\n          if (!this.pendingWriteCallback) {\n            throw new Error('Invalid state in write handling code');\n          }\n\n          stream.write(this.pendingWrite, this.pendingWriteCallback);\n        }\n\n        if (this.pendingFinalCallback) {\n          this.trace('calling end() on HTTP/2 stream');\n          stream.end(this.pendingFinalCallback);\n        }\n      }\n    }\n  }, {\n    key: \"sendMetadata\",\n    value: function sendMetadata(metadata) {\n      this.trace('Sending metadata');\n\n      this.channel._startCallStream(this, metadata);\n    }\n  }, {\n    key: \"destroyHttp2Stream\",\n    value: function destroyHttp2Stream() {\n      // The http2 stream could already have been destroyed if cancelWithStatus\n      // is called in response to an internal http2 error.\n      if (this.http2Stream !== null && !this.http2Stream.destroyed) {\n        /* TODO(murgatroid99): Determine if we want to send different RST_STREAM\n         * codes based on the status code */\n        this.http2Stream.close(NGHTTP2_CANCEL);\n      }\n    }\n  }, {\n    key: \"cancelWithStatus\",\n    value: function cancelWithStatus(status, details) {\n      var _this5 = this;\n\n      this.destroyHttp2Stream();\n\n      _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee3() {\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return _this5.handlingTrailers;\n\n              case 2:\n                _this5.endCall({\n                  code: status,\n                  details: details,\n                  metadata: new metadata_1.Metadata()\n                });\n\n              case 3:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3);\n      }))();\n    }\n  }, {\n    key: \"getDeadline\",\n    value: function getDeadline() {\n      return this.options.deadline;\n    }\n  }, {\n    key: \"getCredentials\",\n    value: function getCredentials() {\n      return this.credentials;\n    }\n  }, {\n    key: \"setCredentials\",\n    value: function setCredentials(credentials) {\n      this.credentials = this.channelCallCredentials.compose(credentials);\n    }\n  }, {\n    key: \"getStatus\",\n    value: function getStatus() {\n      return this.finalStatus;\n    }\n  }, {\n    key: \"getPeer\",\n    value: function getPeer() {\n      throw new Error('Not yet implemented');\n    }\n  }, {\n    key: \"getMethod\",\n    value: function getMethod() {\n      return this.methodName;\n    }\n  }, {\n    key: \"getHost\",\n    value: function getHost() {\n      return this.options.host;\n    }\n  }, {\n    key: \"_read\",\n    value: function _read(size) {\n      /* If we have already emitted a status, we should not emit any more\n       * messages and we should communicate that the stream has ended */\n      if (this.finalStatus !== null) {\n        this.push(null);\n        return;\n      }\n\n      this.canPush = true;\n\n      if (this.http2Stream === null) {\n        this.pendingRead = true;\n      } else {\n        while (this.unpushedReadMessages.length > 0) {\n          var nextMessage = this.unpushedReadMessages.shift();\n          this.canPush = this.push(nextMessage);\n\n          if (nextMessage === null || !this.canPush) {\n            this.canPush = false;\n            return;\n          }\n        }\n        /* Only resume reading from the http2Stream if we don't have any pending\n         * messages to emit, and we haven't gotten the signal to stop pushing\n         * messages */\n\n\n        this.http2Stream.resume();\n      }\n    }\n  }, {\n    key: \"_write\",\n    value: function _write(chunk, encoding, cb) {\n      var _this6 = this;\n\n      this.trace('write() called with message of length ' + chunk.message.length);\n      this.filterStack.sendMessage(Promise.resolve(chunk)).then(function (message) {\n        if (_this6.http2Stream === null) {\n          _this6.pendingWrite = message.message;\n          _this6.pendingWriteCallback = cb;\n        } else {\n          _this6.http2Stream.write(message.message, cb);\n        }\n      }, this.handleFilterError.bind(this));\n    }\n  }, {\n    key: \"_final\",\n    value: function _final(cb) {\n      this.trace('end() called');\n\n      if (this.http2Stream === null) {\n        this.pendingFinalCallback = cb;\n      } else {\n        this.trace('calling end() on HTTP/2 stream');\n        this.http2Stream.end(cb);\n      }\n    }\n  }]);\n\n  return Http2CallStream;\n}(stream_1.Duplex);\n\nexports.Http2CallStream = Http2CallStream;","map":null,"metadata":{},"sourceType":"script"}