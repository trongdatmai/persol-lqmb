{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nvar _toConsumableArray = require(\"/Users/maidat/Desktop/team-lq/persol-lqmb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _classCallCheck = require(\"/Users/maidat/Desktop/team-lq/persol-lqmb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/maidat/Desktop/team-lq/persol-lqmb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar http2 = require(\"http2\");\n\nvar tls_1 = require(\"tls\");\n\nvar channel_1 = require(\"./channel\");\n\nvar backoff_timeout_1 = require(\"./backoff-timeout\");\n\nvar resolver_1 = require(\"./resolver\");\n\nvar logging = require(\"./logging\");\n\nvar constants_1 = require(\"./constants\");\n\nvar _require = require('../../package.json'),\n    clientVersion = _require.version;\n\nvar TRACER_NAME = 'subchannel';\n\nfunction trace(text) {\n  logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\n\nvar MIN_CONNECT_TIMEOUT_MS = 20000;\nvar INITIAL_BACKOFF_MS = 1000;\nvar BACKOFF_MULTIPLIER = 1.6;\nvar MAX_BACKOFF_MS = 120000;\nvar BACKOFF_JITTER = 0.2;\n/* setInterval and setTimeout only accept signed 32 bit integers. JS doesn't\n * have a constant for the max signed 32 bit integer, so this is a simple way\n * to calculate it */\n\nvar KEEPALIVE_MAX_TIME_MS = ~(1 << 31);\nvar KEEPALIVE_TIMEOUT_MS = 20000;\nvar _http2$constants = http2.constants,\n    HTTP2_HEADER_AUTHORITY = _http2$constants.HTTP2_HEADER_AUTHORITY,\n    HTTP2_HEADER_CONTENT_TYPE = _http2$constants.HTTP2_HEADER_CONTENT_TYPE,\n    HTTP2_HEADER_METHOD = _http2$constants.HTTP2_HEADER_METHOD,\n    HTTP2_HEADER_PATH = _http2$constants.HTTP2_HEADER_PATH,\n    HTTP2_HEADER_TE = _http2$constants.HTTP2_HEADER_TE,\n    HTTP2_HEADER_USER_AGENT = _http2$constants.HTTP2_HEADER_USER_AGENT;\n/**\n * Get a number uniformly at random in the range [min, max)\n * @param min\n * @param max\n */\n\nfunction uniformRandom(min, max) {\n  return Math.random() * (max - min) + min;\n}\n\nvar tooManyPingsData = Buffer.from('too_many_pings', 'ascii');\n\nvar Subchannel =\n/*#__PURE__*/\nfunction () {\n  /**\n   * A class representing a connection to a single backend.\n   * @param channelTarget The target string for the channel as a whole\n   * @param subchannelAddress The address for the backend that this subchannel\n   *     will connect to\n   * @param options The channel options, plus any specific subchannel options\n   *     for this subchannel\n   * @param credentials The channel credentials used to establish this\n   *     connection\n   */\n  function Subchannel(channelTarget, subchannelAddress, options, credentials) {\n    var _this = this;\n\n    _classCallCheck(this, Subchannel);\n\n    this.channelTarget = channelTarget;\n    this.subchannelAddress = subchannelAddress;\n    this.options = options;\n    this.credentials = credentials;\n    /**\n     * The subchannel's current connectivity state. Invariant: `session` === `null`\n     * if and only if `connectivityState` is IDLE or TRANSIENT_FAILURE.\n     */\n\n    this.connectivityState = channel_1.ConnectivityState.IDLE;\n    /**\n     * The underlying http2 session used to make requests.\n     */\n\n    this.session = null;\n    /**\n     * Indicates that the subchannel should transition from TRANSIENT_FAILURE to\n     * CONNECTING instead of IDLE when the backoff timeout ends.\n     */\n\n    this.continueConnecting = false;\n    /**\n     * A list of listener functions that will be called whenever the connectivity\n     * state changes. Will be modified by `addConnectivityStateListener` and\n     * `removeConnectivityStateListener`\n     */\n\n    this.stateListeners = [];\n    /**\n     * A list of listener functions that will be called when the underlying\n     * socket disconnects. Used for ending active calls with an UNAVAILABLE\n     * status.\n     */\n\n    this.disconnectListeners = [];\n    /**\n     * The amount of time in between sending pings\n     */\n\n    this.keepaliveTimeMs = KEEPALIVE_MAX_TIME_MS;\n    /**\n     * The amount of time to wait for an acknowledgement after sending a ping\n     */\n\n    this.keepaliveTimeoutMs = KEEPALIVE_TIMEOUT_MS;\n    /**\n     * Tracks calls with references to this subchannel\n     */\n\n    this.callRefcount = 0;\n    /**\n     * Tracks channels and subchannel pools with references to this subchannel\n     */\n\n    this.refcount = 0; // Build user-agent string.\n\n    this.userAgent = [options['grpc.primary_user_agent'], \"grpc-node-js/\".concat(clientVersion), options['grpc.secondary_user_agent']].filter(function (e) {\n      return e;\n    }).join(' '); // remove falsey values first\n\n    if ('grpc.keepalive_time_ms' in options) {\n      this.keepaliveTimeMs = options['grpc.keepalive_time_ms'];\n    }\n\n    if ('grpc.keepalive_timeout_ms' in options) {\n      this.keepaliveTimeoutMs = options['grpc.keepalive_timeout_ms'];\n    }\n\n    this.keepaliveIntervalId = setTimeout(function () {}, 0);\n    clearTimeout(this.keepaliveIntervalId);\n    this.keepaliveTimeoutId = setTimeout(function () {}, 0);\n    clearTimeout(this.keepaliveTimeoutId);\n    var backoffOptions = {\n      initialDelay: options['grpc.initial_reconnect_backoff_ms'],\n      maxDelay: options['grpc.max_reconnect_backoff_ms']\n    };\n    this.backoffTimeout = new backoff_timeout_1.BackoffTimeout(function () {\n      if (_this.continueConnecting) {\n        _this.transitionToState([channel_1.ConnectivityState.TRANSIENT_FAILURE, channel_1.ConnectivityState.CONNECTING], channel_1.ConnectivityState.CONNECTING);\n      } else {\n        _this.transitionToState([channel_1.ConnectivityState.TRANSIENT_FAILURE, channel_1.ConnectivityState.CONNECTING], channel_1.ConnectivityState.IDLE);\n      }\n    }, backoffOptions);\n  }\n  /**\n   * Start a backoff timer with the current nextBackoff timeout\n   */\n\n\n  _createClass(Subchannel, [{\n    key: \"startBackoff\",\n    value: function startBackoff() {\n      this.backoffTimeout.runOnce();\n    }\n  }, {\n    key: \"stopBackoff\",\n    value: function stopBackoff() {\n      this.backoffTimeout.stop();\n      this.backoffTimeout.reset();\n    }\n  }, {\n    key: \"sendPing\",\n    value: function sendPing() {\n      var _this2 = this;\n\n      this.keepaliveTimeoutId = setTimeout(function () {\n        _this2.transitionToState([channel_1.ConnectivityState.READY], channel_1.ConnectivityState.IDLE);\n      }, this.keepaliveTimeoutMs);\n      this.session.ping(function (err, duration, payload) {\n        clearTimeout(_this2.keepaliveTimeoutId);\n      });\n    }\n  }, {\n    key: \"startKeepalivePings\",\n    value: function startKeepalivePings() {\n      var _this3 = this;\n\n      this.keepaliveIntervalId = setInterval(function () {\n        _this3.sendPing();\n      }, this.keepaliveTimeMs);\n      this.sendPing();\n    }\n  }, {\n    key: \"stopKeepalivePings\",\n    value: function stopKeepalivePings() {\n      clearInterval(this.keepaliveIntervalId);\n      clearTimeout(this.keepaliveTimeoutId);\n    }\n  }, {\n    key: \"startConnectingInternal\",\n    value: function startConnectingInternal() {\n      var _this4 = this;\n\n      var connectionOptions = this.credentials._getConnectionOptions() || {};\n      var addressScheme = 'http://';\n\n      if ('secureContext' in connectionOptions) {\n        addressScheme = 'https://'; // If provided, the value of grpc.ssl_target_name_override should be used\n        // to override the target hostname when checking server identity.\n        // This option is used for testing only.\n\n        if (this.options['grpc.ssl_target_name_override']) {\n          var sslTargetNameOverride = this.options['grpc.ssl_target_name_override'];\n\n          connectionOptions.checkServerIdentity = function (host, cert) {\n            return tls_1.checkServerIdentity(sslTargetNameOverride, cert);\n          };\n\n          connectionOptions.servername = sslTargetNameOverride;\n        } else {\n          connectionOptions.servername = resolver_1.getDefaultAuthority(this.channelTarget);\n        }\n      }\n\n      var session = http2.connect(addressScheme + this.subchannelAddress, connectionOptions);\n      this.session = session;\n      session.unref();\n      /* For all of these events, check if the session at the time of the event\n       * is the same one currently attached to this subchannel, to ensure that\n       * old events from previous connection attempts cannot cause invalid state\n       * transitions. */\n\n      session.once('connect', function () {\n        if (_this4.session === session) {\n          _this4.transitionToState([channel_1.ConnectivityState.CONNECTING], channel_1.ConnectivityState.READY);\n        }\n      });\n      session.once('close', function () {\n        if (_this4.session === session) {\n          _this4.transitionToState([channel_1.ConnectivityState.CONNECTING], channel_1.ConnectivityState.TRANSIENT_FAILURE);\n          /* Transitioning directly to IDLE here should be OK because we are not\n           * doing any backoff, because a connection was established at some\n           * point */\n\n\n          _this4.transitionToState([channel_1.ConnectivityState.READY], channel_1.ConnectivityState.IDLE);\n        }\n      });\n      session.once('goaway', function (errorCode, lastStreamID, opaqueData) {\n        if (_this4.session === session) {\n          /* See the last paragraph of\n           * https://github.com/grpc/proposal/blob/master/A8-client-side-keepalive.md#basic-keepalive */\n          if (errorCode === http2.constants.NGHTTP2_ENHANCE_YOUR_CALM && opaqueData.equals(tooManyPingsData)) {\n            logging.log(constants_1.LogVerbosity.ERROR, \"Connection to \".concat(_this4.channelTarget, \" rejected by server because of excess pings\"));\n            _this4.keepaliveTimeMs = Math.min(2 * _this4.keepaliveTimeMs, KEEPALIVE_MAX_TIME_MS);\n          }\n\n          _this4.transitionToState([channel_1.ConnectivityState.CONNECTING, channel_1.ConnectivityState.READY], channel_1.ConnectivityState.IDLE);\n        }\n      });\n      session.once('error', function (error) {\n        /* Do nothing here. Any error should also trigger a close event, which is\n         * where we want to handle that.  */\n      });\n    }\n    /**\n     * Initiate a state transition from any element of oldStates to the new\n     * state. If the current connectivityState is not in oldStates, do nothing.\n     * @param oldStates The set of states to transition from\n     * @param newState The state to transition to\n     * @returns True if the state changed, false otherwise\n     */\n\n  }, {\n    key: \"transitionToState\",\n    value: function transitionToState(oldStates, newState) {\n      var _this5 = this;\n\n      if (oldStates.indexOf(this.connectivityState) === -1) {\n        return false;\n      }\n\n      trace(this.subchannelAddress + ' ' + channel_1.ConnectivityState[this.connectivityState] + ' -> ' + channel_1.ConnectivityState[newState]);\n      var previousState = this.connectivityState;\n      this.connectivityState = newState;\n\n      switch (newState) {\n        case channel_1.ConnectivityState.READY:\n          this.stopBackoff();\n          this.session.socket.once('close', function () {\n            var _iteratorNormalCompletion = true;\n            var _didIteratorError = false;\n            var _iteratorError = undefined;\n\n            try {\n              for (var _iterator = _this5.disconnectListeners[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                var listener = _step.value;\n                listener();\n              }\n            } catch (err) {\n              _didIteratorError = true;\n              _iteratorError = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion && _iterator.return != null) {\n                  _iterator.return();\n                }\n              } finally {\n                if (_didIteratorError) {\n                  throw _iteratorError;\n                }\n              }\n            }\n          });\n          break;\n\n        case channel_1.ConnectivityState.CONNECTING:\n          this.startBackoff();\n          this.startConnectingInternal();\n          this.continueConnecting = false;\n          break;\n\n        case channel_1.ConnectivityState.TRANSIENT_FAILURE:\n          if (this.session) {\n            this.session.close();\n          }\n\n          this.session = null;\n          this.stopKeepalivePings();\n          break;\n\n        case channel_1.ConnectivityState.IDLE:\n          /* Stopping the backoff timer here is probably redundant because we\n           * should only transition to the IDLE state as a result of the timer\n           * ending, but we still want to reset the backoff timeout. */\n          this.stopBackoff();\n\n          if (this.session) {\n            this.session.close();\n          }\n\n          this.session = null;\n          this.stopKeepalivePings();\n          break;\n\n        default:\n          throw new Error(\"Invalid state: unknown ConnectivityState \".concat(newState));\n      }\n      /* We use a shallow copy of the stateListeners array in case a listener\n       * is removed during this iteration */\n\n\n      for (var _i = 0, _arr = _toConsumableArray(this.stateListeners); _i < _arr.length; _i++) {\n        var listener = _arr[_i];\n        listener(this, previousState, newState);\n      }\n\n      return true;\n    }\n    /**\n     * Check if the subchannel associated with zero calls and with zero channels.\n     * If so, shut it down.\n     */\n\n  }, {\n    key: \"checkBothRefcounts\",\n    value: function checkBothRefcounts() {\n      /* If no calls, channels, or subchannel pools have any more references to\n       * this subchannel, we can be sure it will never be used again. */\n      if (this.callRefcount === 0 && this.refcount === 0) {\n        this.transitionToState([channel_1.ConnectivityState.CONNECTING, channel_1.ConnectivityState.IDLE, channel_1.ConnectivityState.READY], channel_1.ConnectivityState.TRANSIENT_FAILURE);\n      }\n    }\n  }, {\n    key: \"callRef\",\n    value: function callRef() {\n      trace(this.subchannelAddress + ' callRefcount ' + this.callRefcount + ' -> ' + (this.callRefcount + 1));\n\n      if (this.callRefcount === 0) {\n        if (this.session) {\n          this.session.ref();\n        }\n\n        this.startKeepalivePings();\n      }\n\n      this.callRefcount += 1;\n    }\n  }, {\n    key: \"callUnref\",\n    value: function callUnref() {\n      trace(this.subchannelAddress + ' callRefcount ' + this.callRefcount + ' -> ' + (this.callRefcount - 1));\n      this.callRefcount -= 1;\n\n      if (this.callRefcount === 0) {\n        if (this.session) {\n          this.session.unref();\n        }\n\n        this.stopKeepalivePings();\n        this.checkBothRefcounts();\n      }\n    }\n  }, {\n    key: \"ref\",\n    value: function ref() {\n      trace(this.subchannelAddress + ' callRefcount ' + this.refcount + ' -> ' + (this.refcount + 1));\n      this.refcount += 1;\n    }\n  }, {\n    key: \"unref\",\n    value: function unref() {\n      trace(this.subchannelAddress + ' callRefcount ' + this.refcount + ' -> ' + (this.refcount - 1));\n      this.refcount -= 1;\n      this.checkBothRefcounts();\n    }\n  }, {\n    key: \"unrefIfOneRef\",\n    value: function unrefIfOneRef() {\n      if (this.refcount === 1) {\n        this.unref();\n        return true;\n      }\n\n      return false;\n    }\n    /**\n     * Start a stream on the current session with the given `metadata` as headers\n     * and then attach it to the `callStream`. Must only be called if the\n     * subchannel's current connectivity state is READY.\n     * @param metadata\n     * @param callStream\n     */\n\n  }, {\n    key: \"startCallStream\",\n    value: function startCallStream(metadata, callStream) {\n      var headers = metadata.toHttp2Headers();\n      headers[HTTP2_HEADER_AUTHORITY] = callStream.getHost();\n      headers[HTTP2_HEADER_USER_AGENT] = this.userAgent;\n      headers[HTTP2_HEADER_CONTENT_TYPE] = 'application/grpc';\n      headers[HTTP2_HEADER_METHOD] = 'POST';\n      headers[HTTP2_HEADER_PATH] = callStream.getMethod();\n      headers[HTTP2_HEADER_TE] = 'trailers';\n      var http2Stream = this.session.request(headers);\n      callStream.attachHttp2Stream(http2Stream, this);\n    }\n    /**\n     * If the subchannel is currently IDLE, start connecting and switch to the\n     * CONNECTING state. If the subchannel is current in TRANSIENT_FAILURE,\n     * the next time it would transition to IDLE, start connecting again instead.\n     * Otherwise, do nothing.\n     */\n\n  }, {\n    key: \"startConnecting\",\n    value: function startConnecting() {\n      /* First, try to transition from IDLE to connecting. If that doesn't happen\n       * because the state is not currently IDLE, check if it is\n       * TRANSIENT_FAILURE, and if so indicate that it should go back to\n       * connecting after the backoff timer ends. Otherwise do nothing */\n      if (!this.transitionToState([channel_1.ConnectivityState.IDLE], channel_1.ConnectivityState.CONNECTING)) {\n        if (this.connectivityState === channel_1.ConnectivityState.TRANSIENT_FAILURE) {\n          this.continueConnecting = true;\n        }\n      }\n    }\n    /**\n     * Get the subchannel's current connectivity state.\n     */\n\n  }, {\n    key: \"getConnectivityState\",\n    value: function getConnectivityState() {\n      return this.connectivityState;\n    }\n    /**\n     * Add a listener function to be called whenever the subchannel's\n     * connectivity state changes.\n     * @param listener\n     */\n\n  }, {\n    key: \"addConnectivityStateListener\",\n    value: function addConnectivityStateListener(listener) {\n      this.stateListeners.push(listener);\n    }\n    /**\n     * Remove a listener previously added with `addConnectivityStateListener`\n     * @param listener A reference to a function previously passed to\n     *     `addConnectivityStateListener`\n     */\n\n  }, {\n    key: \"removeConnectivityStateListener\",\n    value: function removeConnectivityStateListener(listener) {\n      var listenerIndex = this.stateListeners.indexOf(listener);\n\n      if (listenerIndex > -1) {\n        this.stateListeners.splice(listenerIndex, 1);\n      }\n    }\n  }, {\n    key: \"addDisconnectListener\",\n    value: function addDisconnectListener(listener) {\n      this.disconnectListeners.push(listener);\n    }\n  }, {\n    key: \"removeDisconnectListener\",\n    value: function removeDisconnectListener(listener) {\n      var listenerIndex = this.disconnectListeners.indexOf(listener);\n\n      if (listenerIndex > -1) {\n        this.disconnectListeners.splice(listenerIndex, 1);\n      }\n    }\n    /**\n     * Reset the backoff timeout, and immediately start connecting if in backoff.\n     */\n\n  }, {\n    key: \"resetBackoff\",\n    value: function resetBackoff() {\n      this.backoffTimeout.reset();\n      this.transitionToState([channel_1.ConnectivityState.TRANSIENT_FAILURE], channel_1.ConnectivityState.CONNECTING);\n    }\n  }, {\n    key: \"getAddress\",\n    value: function getAddress() {\n      return this.subchannelAddress;\n    }\n  }]);\n\n  return Subchannel;\n}();\n\nexports.Subchannel = Subchannel;","map":null,"metadata":{},"sourceType":"script"}