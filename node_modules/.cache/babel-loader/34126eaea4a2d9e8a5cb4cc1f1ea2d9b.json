{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 Google LLC\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following disclaimer\n * in the documentation and/or other materials provided with the\n * distribution.\n *     * Neither the name of Google Inc. nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nvar _classCallCheck = require(\"/Users/maidat/Desktop/team-lq/persol-lqmb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/maidat/Desktop/team-lq/persol-lqmb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar status_1 = require(\"../status\");\n\nvar googleError_1 = require(\"../googleError\");\n\nvar warnings_1 = require(\"../warnings\");\n\nvar bundlingUtils_1 = require(\"./bundlingUtils\");\n\nvar task_1 = require(\"./task\");\n\nfunction noop() {}\n/**\n * BundleExecutor stores several timers for each bundle (calls are bundled based\n * on the options passed, each bundle has unique ID that is calculated based on\n * field values). Each timer fires and sends a call after certain amount of\n * time, and if a new request comes to the same bundle, the timer can be\n * restarted.\n */\n\n\nvar BundleExecutor =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Organizes requests for an api service that requires to bundle them.\n   *\n   * @param {BundleOptions} bundleOptions - configures strategy this instance\n   *   uses when executing bundled functions.\n   * @param {BundleDescriptor} bundleDescriptor - the description of the bundling.\n   * @constructor\n   */\n  function BundleExecutor(bundleOptions, bundleDescriptor) {\n    _classCallCheck(this, BundleExecutor);\n\n    this._options = bundleOptions;\n    this._descriptor = bundleDescriptor;\n    this._tasks = {};\n    this._timers = {};\n    this._invocations = {};\n    this._invocationId = 0;\n  }\n  /**\n   * Schedule a method call.\n   *\n   * @param {function} apiCall - the function for an API call.\n   * @param {Object} request - the request object to be bundled with others.\n   * @param {APICallback} callback - the callback to be called when the method finished.\n   * @return {function()} - the function to cancel the scheduled invocation.\n   */\n\n\n  _createClass(BundleExecutor, [{\n    key: \"schedule\",\n    value: function schedule(apiCall, request, callback) {\n      var _this = this;\n\n      var bundleId = bundlingUtils_1.computeBundleId(request, this._descriptor.requestDiscriminatorFields);\n      callback = callback || noop;\n\n      if (bundleId === undefined) {\n        warnings_1.warn('bundling_schedule_bundleid_undefined', 'The request does not have enough information for request bundling. ' + \"Invoking immediately. Request: \".concat(JSON.stringify(request), \" \") + \"discriminator fields: \".concat(this._descriptor.requestDiscriminatorFields));\n        return apiCall(request, callback);\n      }\n\n      if (request[this._descriptor.bundledField] === undefined) {\n        warnings_1.warn('bundling_no_bundled_field', \"Request does not contain field \".concat(this._descriptor.bundledField, \" that must present for bundling. \") + \"Invoking immediately. Request: \".concat(JSON.stringify(request)));\n        return apiCall(request, callback);\n      }\n\n      if (!(bundleId in this._tasks)) {\n        this._tasks[bundleId] = new task_1.Task(apiCall, request, this._descriptor.bundledField, this._descriptor.subresponseField);\n      }\n\n      var task = this._tasks[bundleId];\n      callback.id = String(this._invocationId++);\n      this._invocations[callback.id] = bundleId;\n      var bundledField = request[this._descriptor.bundledField];\n      var elementCount = bundledField.length;\n      var requestBytes = 0;\n      var self = this;\n      bundledField.forEach(function (obj) {\n        requestBytes += _this._descriptor.byteLengthFunction(obj);\n      });\n      var countLimit = this._options.elementCountLimit || 0;\n      var byteLimit = this._options.requestByteLimit || 0;\n\n      if (countLimit > 0 && elementCount > countLimit || byteLimit > 0 && requestBytes >= byteLimit) {\n        var message;\n\n        if (countLimit > 0 && elementCount > countLimit) {\n          message = 'The number of elements ' + elementCount + ' exceeds the limit ' + this._options.elementCountLimit;\n        } else {\n          message = 'The required bytes ' + requestBytes + ' exceeds the limit ' + this._options.requestByteLimit;\n        }\n\n        var error = new googleError_1.GoogleError(message);\n        error.code = status_1.Status.INVALID_ARGUMENT;\n        callback(error);\n        return {\n          cancel: noop\n        };\n      }\n\n      var existingCount = task.getElementCount();\n      var existingBytes = task.getRequestByteSize();\n\n      if (countLimit > 0 && elementCount + existingCount >= countLimit || byteLimit > 0 && requestBytes + existingBytes >= byteLimit) {\n        this._runNow(bundleId);\n\n        this._tasks[bundleId] = new task_1.Task(apiCall, request, this._descriptor.bundledField, this._descriptor.subresponseField);\n        task = this._tasks[bundleId];\n      }\n\n      task.extend(bundledField, requestBytes, callback);\n      var ret = {\n        cancel: function cancel() {\n          self._cancel(callback.id);\n        }\n      };\n      var countThreshold = this._options.elementCountThreshold || 0;\n      var sizeThreshold = this._options.requestByteThreshold || 0;\n\n      if (countThreshold > 0 && task.getElementCount() >= countThreshold || sizeThreshold > 0 && task.getRequestByteSize() >= sizeThreshold) {\n        this._runNow(bundleId);\n\n        return ret;\n      }\n\n      if (!(bundleId in this._timers) && this._options.delayThreshold > 0) {\n        this._timers[bundleId] = setTimeout(function () {\n          delete _this._timers[bundleId];\n\n          _this._runNow(bundleId);\n        }, this._options.delayThreshold);\n      }\n\n      return ret;\n    }\n    /**\n     * Clears scheduled timeout if it exists.\n     *\n     * @param {String} bundleId - the id for the task whose timeout needs to be\n     *   cleared.\n     * @private\n     */\n\n  }, {\n    key: \"_maybeClearTimeout\",\n    value: function _maybeClearTimeout(bundleId) {\n      if (bundleId in this._timers) {\n        var timerId = this._timers[bundleId];\n        delete this._timers[bundleId];\n        clearTimeout(timerId);\n      }\n    }\n    /**\n     * Cancels an event.\n     *\n     * @param {String} id - The id for the event in the task.\n     * @private\n     */\n\n  }, {\n    key: \"_cancel\",\n    value: function _cancel(id) {\n      if (!(id in this._invocations)) {\n        return;\n      }\n\n      var bundleId = this._invocations[id];\n\n      if (!(bundleId in this._tasks)) {\n        return;\n      }\n\n      var task = this._tasks[bundleId];\n      delete this._invocations[id];\n\n      if (task.cancel(id)) {\n        this._maybeClearTimeout(bundleId);\n\n        delete this._tasks[bundleId];\n      }\n    }\n    /**\n     * Invokes a task.\n     *\n     * @param {String} bundleId - The id for the task.\n     * @private\n     */\n\n  }, {\n    key: \"_runNow\",\n    value: function _runNow(bundleId) {\n      var _this2 = this;\n\n      if (!(bundleId in this._tasks)) {\n        warnings_1.warn('bundle_runnow_bundleid_unknown', \"No such bundleid: \".concat(bundleId));\n        return;\n      }\n\n      this._maybeClearTimeout(bundleId);\n\n      var task = this._tasks[bundleId];\n      delete this._tasks[bundleId];\n      task.run().forEach(function (id) {\n        delete _this2._invocations[id];\n      });\n    }\n  }]);\n\n  return BundleExecutor;\n}();\n\nexports.BundleExecutor = BundleExecutor;","map":null,"metadata":{},"sourceType":"script"}