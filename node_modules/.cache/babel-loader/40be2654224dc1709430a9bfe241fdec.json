{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nvar _classCallCheck = require(\"/Users/maidat/Desktop/team-lq/persol-lqmb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/maidat/Desktop/team-lq/persol-lqmb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar call_stream_1 = require(\"./call-stream\");\n\nvar resolving_load_balancer_1 = require(\"./resolving-load-balancer\");\n\nvar subchannel_pool_1 = require(\"./subchannel-pool\");\n\nvar picker_1 = require(\"./picker\");\n\nvar constants_1 = require(\"./constants\");\n\nvar filter_stack_1 = require(\"./filter-stack\");\n\nvar call_credentials_filter_1 = require(\"./call-credentials-filter\");\n\nvar deadline_filter_1 = require(\"./deadline-filter\");\n\nvar metadata_status_filter_1 = require(\"./metadata-status-filter\");\n\nvar compression_filter_1 = require(\"./compression-filter\");\n\nvar resolver_1 = require(\"./resolver\");\n\nvar service_config_1 = require(\"./service-config\");\n\nvar logging_1 = require(\"./logging\");\n\nvar ConnectivityState;\n\n(function (ConnectivityState) {\n  ConnectivityState[ConnectivityState[\"CONNECTING\"] = 0] = \"CONNECTING\";\n  ConnectivityState[ConnectivityState[\"READY\"] = 1] = \"READY\";\n  ConnectivityState[ConnectivityState[\"TRANSIENT_FAILURE\"] = 2] = \"TRANSIENT_FAILURE\";\n  ConnectivityState[ConnectivityState[\"IDLE\"] = 3] = \"IDLE\";\n  ConnectivityState[ConnectivityState[\"SHUTDOWN\"] = 4] = \"SHUTDOWN\";\n})(ConnectivityState = exports.ConnectivityState || (exports.ConnectivityState = {}));\n\nvar nextCallNumber = 0;\n\nfunction getNewCallNumber() {\n  var callNumber = nextCallNumber;\n  nextCallNumber += 1;\n\n  if (nextCallNumber >= Number.MAX_SAFE_INTEGER) {\n    nextCallNumber = 0;\n  }\n\n  return callNumber;\n}\n\nvar ChannelImplementation =\n/*#__PURE__*/\nfunction () {\n  function ChannelImplementation(target, credentials, options) {\n    var _this = this;\n\n    _classCallCheck(this, ChannelImplementation);\n\n    var _a;\n\n    this.target = target;\n    this.credentials = credentials;\n    this.options = options;\n    this.connectivityState = ConnectivityState.IDLE;\n    this.currentPicker = new picker_1.UnavailablePicker();\n    this.pickQueue = [];\n    this.connectivityStateWatchers = [];\n    /* The global boolean parameter to getSubchannelPool has the inverse meaning to what\n     * the grpc.use_local_subchannel_pool channel option means. */\n\n    this.subchannelPool = subchannel_pool_1.getSubchannelPool((_a = options['grpc.use_local_subchannel_pool'], _a !== null && _a !== void 0 ? _a : 0) === 0);\n    var channelControlHelper = {\n      createSubchannel: function createSubchannel(subchannelAddress, subchannelArgs) {\n        return _this.subchannelPool.getOrCreateSubchannel(_this.target, subchannelAddress, Object.assign({}, _this.options, subchannelArgs), _this.credentials);\n      },\n      updateState: function updateState(connectivityState, picker) {\n        _this.currentPicker = picker;\n\n        var queueCopy = _this.pickQueue.slice();\n\n        _this.pickQueue = [];\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = queueCopy[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var _ref2 = _step.value;\n            var callStream = _ref2.callStream;\n            var callMetadata = _ref2.callMetadata;\n\n            _this.tryPick(callStream, callMetadata);\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n\n        _this.updateState(connectivityState);\n      },\n      requestReresolution: function requestReresolution() {\n        // This should never be called.\n        throw new Error('Resolving load balancer should never call requestReresolution');\n      }\n    }; // TODO(murgatroid99): check channel arg for default service config\n\n    var defaultServiceConfig = {\n      loadBalancingConfig: [],\n      methodConfig: []\n    };\n\n    if (options['grpc.service_config']) {\n      defaultServiceConfig = service_config_1.validateServiceConfig(JSON.parse(options['grpc.service_config']));\n    }\n\n    this.resolvingLoadBalancer = new resolving_load_balancer_1.ResolvingLoadBalancer(target, channelControlHelper, defaultServiceConfig);\n    this.filterStackFactory = new filter_stack_1.FilterStackFactory([new call_credentials_filter_1.CallCredentialsFilterFactory(this), new deadline_filter_1.DeadlineFilterFactory(this), new metadata_status_filter_1.MetadataStatusFilterFactory(this), new compression_filter_1.CompressionFilterFactory(this)]); // TODO(murgatroid99): Add more centralized handling of channel options\n\n    if (this.options['grpc.default_authority']) {\n      this.defaultAuthority = this.options['grpc.default_authority'];\n    } else {\n      this.defaultAuthority = resolver_1.getDefaultAuthority(target);\n    }\n  }\n  /**\n   * Check the picker output for the given call and corresponding metadata,\n   * and take any relevant actions. Should not be called while iterating\n   * over pickQueue.\n   * @param callStream\n   * @param callMetadata\n   */\n\n\n  _createClass(ChannelImplementation, [{\n    key: \"tryPick\",\n    value: function tryPick(callStream, callMetadata) {\n      var pickResult = this.currentPicker.pick({\n        metadata: callMetadata\n      });\n\n      switch (pickResult.pickResultType) {\n        case picker_1.PickResultType.COMPLETE:\n          if (pickResult.subchannel === null) {\n            callStream.cancelWithStatus(constants_1.Status.UNAVAILABLE, 'Request dropped by load balancing policy'); // End the call with an error\n          } else {\n            /* If the subchannel disconnects between calling pick and getting\n             * the filter stack metadata, the call will end with an error. */\n            callStream.filterStack.sendMetadata(Promise.resolve(callMetadata)).then(function (finalMetadata) {\n              if (pickResult.subchannel.getConnectivityState() === ConnectivityState.READY) {\n                try {\n                  pickResult.subchannel.startCallStream(finalMetadata, callStream);\n                } catch (error) {\n                  callStream.cancelWithStatus(constants_1.Status.UNAVAILABLE, 'Failed to start call on picked subchannel');\n                }\n              } else {\n                callStream.cancelWithStatus(constants_1.Status.UNAVAILABLE, 'Connection dropped while starting call');\n              }\n            }, function (error) {\n              // We assume the error code isn't 0 (Status.OK)\n              callStream.cancelWithStatus(error.code || constants_1.Status.UNKNOWN, \"Getting metadata from plugin failed with error: \".concat(error.message));\n            });\n          }\n\n          break;\n\n        case picker_1.PickResultType.QUEUE:\n          this.pickQueue.push({\n            callStream: callStream,\n            callMetadata: callMetadata\n          });\n          break;\n\n        case picker_1.PickResultType.TRANSIENT_FAILURE:\n          if (callMetadata.getOptions().waitForReady) {\n            this.pickQueue.push({\n              callStream: callStream,\n              callMetadata: callMetadata\n            });\n          } else {\n            callStream.cancelWithStatus(pickResult.status.code, pickResult.status.details);\n          }\n\n          break;\n\n        default:\n          throw new Error(\"Invalid state: unknown pickResultType \".concat(pickResult.pickResultType));\n      }\n    }\n  }, {\n    key: \"removeConnectivityStateWatcher\",\n    value: function removeConnectivityStateWatcher(watcherObject) {\n      var watcherIndex = this.connectivityStateWatchers.findIndex(function (value) {\n        return value === watcherObject;\n      });\n\n      if (watcherIndex >= 0) {\n        this.connectivityStateWatchers.splice(watcherIndex, 1);\n      }\n    }\n  }, {\n    key: \"updateState\",\n    value: function updateState(newState) {\n      logging_1.trace(constants_1.LogVerbosity.DEBUG, 'connectivity_state', this.target + ' ' + ConnectivityState[this.connectivityState] + ' -> ' + ConnectivityState[newState]);\n      this.connectivityState = newState;\n      var watchersCopy = this.connectivityStateWatchers.slice();\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = watchersCopy[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var watcherObject = _step2.value;\n\n          if (newState !== watcherObject.currentState) {\n            watcherObject.callback();\n            clearTimeout(watcherObject.timer);\n            this.removeConnectivityStateWatcher(watcherObject);\n          }\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"_startCallStream\",\n    value: function _startCallStream(stream, metadata) {\n      this.tryPick(stream, metadata.clone());\n    }\n  }, {\n    key: \"close\",\n    value: function close() {\n      this.resolvingLoadBalancer.destroy();\n      this.updateState(ConnectivityState.SHUTDOWN);\n      this.subchannelPool.unrefUnusedSubchannels();\n    }\n  }, {\n    key: \"getTarget\",\n    value: function getTarget() {\n      return this.target;\n    }\n  }, {\n    key: \"getConnectivityState\",\n    value: function getConnectivityState(tryToConnect) {\n      var connectivityState = this.connectivityState;\n\n      if (tryToConnect) {\n        this.resolvingLoadBalancer.exitIdle();\n      }\n\n      return connectivityState;\n    }\n  }, {\n    key: \"watchConnectivityState\",\n    value: function watchConnectivityState(currentState, deadline, callback) {\n      var _this2 = this;\n\n      var deadlineDate = deadline instanceof Date ? deadline : new Date(deadline);\n      var now = new Date();\n\n      if (deadlineDate <= now) {\n        process.nextTick(callback, new Error('Deadline passed without connectivity state change'));\n        return;\n      }\n\n      var watcherObject = {\n        currentState: currentState,\n        callback: callback,\n        timer: setTimeout(function () {\n          _this2.removeConnectivityStateWatcher(watcherObject);\n\n          callback(new Error('Deadline passed without connectivity state change'));\n        }, deadlineDate.getTime() - now.getTime())\n      };\n      this.connectivityStateWatchers.push(watcherObject);\n    }\n  }, {\n    key: \"createCall\",\n    value: function createCall(method, deadline, host, parentCall, propagateFlags) {\n      if (this.connectivityState === ConnectivityState.SHUTDOWN) {\n        throw new Error('Channel has been shut down');\n      }\n\n      var callNumber = getNewCallNumber();\n      logging_1.trace(constants_1.LogVerbosity.DEBUG, 'channel', this.target + ' createCall [' + callNumber + '] method=\"' + method + '\", deadline=' + deadline);\n      var finalOptions = {\n        deadline: deadline === null || deadline === undefined ? Infinity : deadline,\n        flags: propagateFlags || 0,\n        host: host || this.defaultAuthority,\n        parentCall: parentCall || null\n      };\n      var stream = new call_stream_1.Http2CallStream(method, this, finalOptions, this.filterStackFactory, this.credentials._getCallCredentials(), callNumber);\n      return stream;\n    }\n  }]);\n\n  return ChannelImplementation;\n}();\n\nexports.ChannelImplementation = ChannelImplementation;","map":null,"metadata":{},"sourceType":"script"}