{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2019 Google LLC\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following disclaimer\n * in the documentation and/or other materials provided with the\n * distribution.\n *     * Neither the name of Google Inc. nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nvar _regeneratorRuntime = require(\"/Users/maidat/Desktop/team-lq/persol-lqmb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _slicedToArray = require(\"/Users/maidat/Desktop/team-lq/persol-lqmb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _asyncToGenerator = require(\"/Users/maidat/Desktop/team-lq/persol-lqmb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _toConsumableArray = require(\"/Users/maidat/Desktop/team-lq/persol-lqmb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _classCallCheck = require(\"/Users/maidat/Desktop/team-lq/persol-lqmb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/maidat/Desktop/team-lq/persol-lqmb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar protobuf = require(\"protobufjs\");\n\nexports.protobuf = protobuf;\n\nvar gax = require(\"./gax\");\n\nvar nodeFetch = require(\"node-fetch\");\n\nvar routingHeader = require(\"./routingHeader\");\n\nexports.routingHeader = routingHeader;\n\nvar abort_controller_1 = require(\"abort-controller\");\n\nvar status_1 = require(\"./status\");\n\nvar google_auth_library_1 = require(\"google-auth-library\");\n\nvar operationsClient_1 = require(\"./operationsClient\");\n\nvar createApiCall_1 = require(\"./createApiCall\");\n\nvar isbrowser_1 = require(\"./isbrowser\");\n\nvar fallbackError_1 = require(\"./fallbackError\");\n\nvar pathTemplate_1 = require(\"./pathTemplate\");\n\nexports.PathTemplate = pathTemplate_1.PathTemplate;\n\nvar gax_1 = require(\"./gax\");\n\nexports.CallSettings = gax_1.CallSettings;\nexports.constructSettings = gax_1.constructSettings;\nexports.RetryOptions = gax_1.RetryOptions;\nexports.version = require('../../package.json').version + '-fallback';\n\nvar descriptor_1 = require(\"./descriptor\");\n\nexports.BundleDescriptor = descriptor_1.BundleDescriptor;\nexports.LongrunningDescriptor = descriptor_1.LongrunningDescriptor;\nexports.PageDescriptor = descriptor_1.PageDescriptor;\nexports.StreamDescriptor = descriptor_1.StreamDescriptor;\n\nvar streaming_1 = require(\"./streamingCalls/streaming\");\n\nexports.StreamType = streaming_1.StreamType;\nvar CLIENT_VERSION_HEADER = 'x-goog-api-client';\n\nvar GrpcClient =\n/*#__PURE__*/\nfunction () {\n  /**\n   * gRPC-fallback version of GrpcClient\n   * Implements GrpcClient API for a browser using grpc-fallback protocol (sends serialized protobuf to HTTP/1 $rpc endpoint).\n   *\n   * @param {Object=} options.auth - An instance of OAuth2Client to use in browser, or an instance of GoogleAuth from google-auth-library\n   *  to use in Node.js. Required for browser, optional for Node.js.\n   * @param {Function=} options.promise - A constructor for a promise that\n   * implements the ES6 specification of promise.\n   * @constructor\n   */\n  function GrpcClient() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, GrpcClient);\n\n    if (isbrowser_1.isBrowser()) {\n      if (!options.auth) {\n        throw new Error(JSON.stringify(options) + 'You need to pass auth instance to use gRPC-fallback client in browser. Use OAuth2Client from google-auth-library.');\n      }\n\n      this.auth = options.auth;\n    } else {\n      this.auth = options.auth || new google_auth_library_1.GoogleAuth(options);\n    }\n\n    this.promise = 'promise' in options ? options.promise : Promise;\n    this.fallback = true;\n    this.grpcVersion = 'fallback'; // won't be used anywhere but we need it to exist in the class\n  }\n  /**\n   * gRPC-fallback version of loadProto\n   * Loads the protobuf root object from a JSON object created from a proto file\n   * @param {Object} jsonObject - A JSON version of a protofile created usin protobuf.js\n   * @returns {Object} Root namespace of proto JSON\n   */\n\n\n  _createClass(GrpcClient, [{\n    key: \"loadProto\",\n    value: function loadProto(jsonObject) {\n      var rootObject = protobuf.Root.fromJSON(jsonObject);\n      return rootObject;\n    }\n  }, {\n    key: \"getServiceMethods\",\n    value: function getServiceMethods(service) {\n      var methods = Object.keys(service.methods);\n      var methodsLowerCamelCase = methods.map(function (method) {\n        return method[0].toLowerCase() + method.substring(1);\n      });\n      return methodsLowerCamelCase;\n    }\n    /**\n     * gRPC-fallback version of constructSettings\n     * A wrapper of {@link constructSettings} function under the gRPC context.\n     *\n     * Most of parameters are common among constructSettings, please take a look.\n     * @param {string} serviceName - The fullly-qualified name of the service.\n     * @param {Object} clientConfig - A dictionary of the client config.\n     * @param {Object} configOverrides - A dictionary of overriding configs.\n     * @param {Object} headers - A dictionary of additional HTTP header name to\n     *   its value.\n     * @return {Object} A mapping of method names to CallSettings.\n     */\n\n  }, {\n    key: \"constructSettings\",\n    value: function constructSettings(serviceName, clientConfig, configOverrides, headers) {\n      function buildMetadata(abTests, moreHeaders) {\n        var metadata = {};\n\n        if (!headers) {\n          headers = {};\n        } // Since gRPC expects each header to be an array,\n        // we are doing the same for fallback here.\n\n\n        for (var key in headers) {\n          if (headers.hasOwnProperty(key)) {\n            metadata[key] = Array.isArray(headers[key]) ? headers[key] : [headers[key]];\n          }\n        } // gRPC-fallback request must have 'grpc-web/' in 'x-goog-api-client'\n\n\n        var clientVersions = [];\n\n        if (metadata[CLIENT_VERSION_HEADER] && metadata[CLIENT_VERSION_HEADER][0]) {\n          clientVersions.push.apply(clientVersions, _toConsumableArray(metadata[CLIENT_VERSION_HEADER][0].split(' ')));\n        }\n\n        clientVersions.push(\"grpc-web/\".concat(exports.version));\n        metadata[CLIENT_VERSION_HEADER] = [clientVersions.join(' ')];\n\n        if (!moreHeaders) {\n          return metadata;\n        }\n\n        for (var _key in moreHeaders) {\n          if (_key.toLowerCase() !== CLIENT_VERSION_HEADER && moreHeaders.hasOwnProperty(_key)) {\n            var value = moreHeaders[_key];\n\n            if (Array.isArray(value)) {\n              if (metadata[_key] === undefined) {\n                metadata[_key] = value;\n              } else {\n                if (Array.isArray(metadata[_key])) {\n                  var _metadata$_key;\n\n                  (_metadata$_key = metadata[_key]).push.apply(_metadata$_key, _toConsumableArray(value));\n                } else {\n                  throw new Error(\"Can not add value \".concat(value, \" to the call metadata.\"));\n                }\n              }\n            } else {\n              metadata[_key] = [value];\n            }\n          }\n        }\n\n        return metadata;\n      }\n\n      return gax.constructSettings(serviceName, clientConfig, configOverrides, status_1.Status, {\n        metadataBuilder: buildMetadata\n      }, this.promise);\n    }\n    /**\n     * gRPC-fallback version of createStub\n     * Creates a gRPC-fallback stub with authentication headers built from supplied OAuth2Client instance\n     *\n     * @param {function} CreateStub - The constructor function of the stub.\n     * @param {Object} service - A protobufjs Service object (as returned by lookupService)\n     * @param {Object} opts - Connection options, as described below.\n     * @param {string} opts.servicePath - The hostname of the API endpoint service.\n     * @param {number} opts.port - The port of the service.\n     * @return {Promise} A promise which resolves to a gRPC-fallback service stub, which is a protobuf.js service stub instance modified to match the gRPC stub API\n     */\n\n  }, {\n    key: \"createStub\",\n    value: function () {\n      var _createStub = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee(service, opts) {\n        var serviceClientImpl, statusDecoder, authHeader, serviceStub, methods, newServiceStub, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _loop, _iterator, _step;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                serviceClientImpl = function _ref3(method, requestData, callback) {\n                  return [method, requestData, callback];\n                };\n\n                // decoder for google.rpc.Status messages\n                statusDecoder = new fallbackError_1.FallbackErrorDecoder();\n\n                if (this.authClient) {\n                  _context.next = 10;\n                  break;\n                }\n\n                if (!(this.auth && 'getClient' in this.auth)) {\n                  _context.next = 9;\n                  break;\n                }\n\n                _context.next = 6;\n                return this.auth.getClient();\n\n              case 6:\n                this.authClient = _context.sent;\n                _context.next = 10;\n                break;\n\n              case 9:\n                if (this.auth && 'getRequestHeaders' in this.auth) {\n                  this.authClient = this.auth;\n                }\n\n              case 10:\n                if (this.authClient) {\n                  _context.next = 12;\n                  break;\n                }\n\n                throw new Error('No authentication was provided');\n\n              case 12:\n                _context.next = 14;\n                return this.authClient.getRequestHeaders();\n\n              case 14:\n                authHeader = _context.sent;\n                serviceStub = service.create(serviceClientImpl, false, false);\n                methods = this.getServiceMethods(service);\n                newServiceStub = service.create(serviceClientImpl, false, false);\n                _iteratorNormalCompletion = true;\n                _didIteratorError = false;\n                _iteratorError = undefined;\n                _context.prev = 21;\n\n                _loop = function _loop() {\n                  var methodName = _step.value;\n\n                  newServiceStub[methodName] = function (req, options, metadata, callback) {\n                    var _serviceStub$methodNa = serviceStub[methodName].apply(serviceStub, [req, callback]),\n                        _serviceStub$methodNa2 = _slicedToArray(_serviceStub$methodNa, 3),\n                        method = _serviceStub$methodNa2[0],\n                        requestData = _serviceStub$methodNa2[1],\n                        serviceCallback = _serviceStub$methodNa2[2]; // tslint:disable-next-line no-any\n\n\n                    var cancelController, cancelSignal;\n\n                    if (isbrowser_1.isBrowser && typeof AbortController !== 'undefined') {\n                      cancelController = new AbortController();\n                    } else {\n                      cancelController = new abort_controller_1.AbortController();\n                    }\n\n                    if (cancelController) {\n                      cancelSignal = cancelController.signal;\n                    }\n\n                    var cancelRequested = false;\n                    var headers = Object.assign({}, authHeader);\n                    headers['Content-Type'] = 'application/x-protobuf';\n\n                    for (var _i = 0, _Object$keys = Object.keys(options); _i < _Object$keys.length; _i++) {\n                      var key = _Object$keys[_i];\n                      headers[key] = options[key][0];\n                    }\n\n                    var grpcFallbackProtocol = opts.protocol || 'https';\n                    var servicePath = opts.servicePath;\n\n                    if (!servicePath && service.options && service.options['(google.api.default_host)']) {\n                      servicePath = service.options['(google.api.default_host)'];\n                    }\n\n                    if (!servicePath) {\n                      serviceCallback(new Error('Service path is undefined'));\n                      return;\n                    }\n\n                    var servicePort;\n                    var match = servicePath.match(/^(.*):(\\d+)$/);\n\n                    if (match) {\n                      servicePath = match[1];\n                      servicePort = match[2];\n                    }\n\n                    if (opts.port) {\n                      servicePort = opts.port;\n                    } else if (!servicePort) {\n                      servicePort = 443;\n                    }\n\n                    var protoNamespaces = [];\n                    var currNamespace = method.parent;\n\n                    while (currNamespace.name !== '') {\n                      protoNamespaces.unshift(currNamespace.name);\n                      currNamespace = currNamespace.parent;\n                    }\n\n                    var protoServiceName = protoNamespaces.join('.');\n                    var rpcName = method.name;\n                    var url = \"\".concat(grpcFallbackProtocol, \"://\").concat(servicePath, \":\").concat(servicePort, \"/$rpc/\").concat(protoServiceName, \"/\").concat(rpcName);\n                    var fetch = isbrowser_1.isBrowser() ? window.fetch : nodeFetch;\n                    fetch(url, {\n                      headers: headers,\n                      method: 'post',\n                      body: requestData,\n                      signal: cancelSignal\n                    }).then(function (response) {\n                      return Promise.all([Promise.resolve(response.ok), response.arrayBuffer()]);\n                    }).then(function (_ref) {\n                      var _ref2 = _slicedToArray(_ref, 2),\n                          ok = _ref2[0],\n                          buffer = _ref2[1];\n\n                      if (!ok) {\n                        var status = statusDecoder.decodeRpcStatus(buffer);\n                        throw new Error(JSON.stringify(status));\n                      }\n\n                      serviceCallback(null, new Uint8Array(buffer));\n                    }).catch(function (err) {\n                      if (!cancelRequested || err.name !== 'AbortError') {\n                        serviceCallback(err);\n                      }\n                    });\n                    return {\n                      cancel: function cancel() {\n                        if (!cancelController) {\n                          console.warn('AbortController not found: Cancellation is not supported in this environment');\n                          return;\n                        }\n\n                        cancelRequested = true;\n                        cancelController.abort();\n                      }\n                    };\n                  };\n                };\n\n                for (_iterator = methods[Symbol.iterator](); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                  _loop();\n                }\n\n                _context.next = 30;\n                break;\n\n              case 26:\n                _context.prev = 26;\n                _context.t0 = _context[\"catch\"](21);\n                _didIteratorError = true;\n                _iteratorError = _context.t0;\n\n              case 30:\n                _context.prev = 30;\n                _context.prev = 31;\n\n                if (!_iteratorNormalCompletion && _iterator.return != null) {\n                  _iterator.return();\n                }\n\n              case 33:\n                _context.prev = 33;\n\n                if (!_didIteratorError) {\n                  _context.next = 36;\n                  break;\n                }\n\n                throw _iteratorError;\n\n              case 36:\n                return _context.finish(33);\n\n              case 37:\n                return _context.finish(30);\n\n              case 38:\n                return _context.abrupt(\"return\", newServiceStub);\n\n              case 39:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[21, 26, 30, 38], [31,, 33, 37]]);\n      }));\n\n      function createStub(_x, _x2) {\n        return _createStub.apply(this, arguments);\n      }\n\n      return createStub;\n    }()\n  }]);\n\n  return GrpcClient;\n}();\n\nexports.GrpcClient = GrpcClient;\n/**\n * gRPC-fallback version of lro\n *\n * @param {Object=} options.auth - An instance of google-auth-library.\n * @param {Function=} options.promise - A constructor for a promise that\n * implements the ES6 specification of promise.\n * @return {Object} A OperationsClientBuilder that will return a OperationsClient\n */\n\nfunction lro(options) {\n  options = Object.assign({\n    scopes: []\n  }, options);\n  var gaxGrpc = new GrpcClient(options);\n  return new operationsClient_1.OperationsClientBuilder(gaxGrpc);\n}\n\nexports.lro = lro;\n/**\n * gRPC-fallback version of createApiCall\n *\n * Converts an rpc call into an API call governed by the settings.\n *\n * In typical usage, `func` will be a promise to a callable used to make an rpc\n * request. This will mostly likely be a bound method from a request stub used\n * to make an rpc call. It is not a direct function but a Promise instance,\n * because of its asynchronism (typically, obtaining the auth information).\n *\n * The result is a function which manages the API call with the given settings\n * and the options on the invocation.\n *\n * Throws exception on unsupported streaming calls\n *\n * @param {Promise<GRPCCall>|GRPCCall} func - is either a promise to be used to make\n *   a bare RPC call, or just a bare RPC call.\n * @param {CallSettings} settings - provides the settings for this call\n * @param {Descriptor} descriptor - optionally specify the descriptor for\n *   the method call.\n * @return {GaxCall} func - a bound method on a request stub used\n *   to make an rpc call.\n */\n\nfunction createApiCall(func, settings, descriptor) {\n  if (descriptor && 'streaming' in descriptor) {\n    return function () {\n      throw new Error('The gRPC-fallback client library (e.g. browser version of the library) currently does not support streaming calls.');\n    };\n  }\n\n  return createApiCall_1.createApiCall(func, settings, descriptor);\n}\n\nexports.createApiCall = createApiCall;","map":null,"metadata":{},"sourceType":"script"}