{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nvar _defineProperty = require(\"/Users/maidat/Desktop/team-lq/persol-lqmb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/defineProperty\");\n\nvar _classCallCheck = require(\"/Users/maidat/Desktop/team-lq/persol-lqmb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/maidat/Desktop/team-lq/persol-lqmb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar load_balancer_1 = require(\"./load-balancer\");\n\nvar channel_1 = require(\"./channel\");\n\nvar picker_1 = require(\"./picker\");\n\nvar TYPE_NAME = 'round_robin';\n\nvar RoundRobinPicker =\n/*#__PURE__*/\nfunction () {\n  function RoundRobinPicker(subchannelList) {\n    var nextIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n    _classCallCheck(this, RoundRobinPicker);\n\n    this.subchannelList = subchannelList;\n    this.nextIndex = nextIndex;\n  }\n\n  _createClass(RoundRobinPicker, [{\n    key: \"pick\",\n    value: function pick(pickArgs) {\n      var pickedSubchannel = this.subchannelList[this.nextIndex];\n      this.nextIndex = (this.nextIndex + 1) % this.subchannelList.length;\n      return {\n        pickResultType: picker_1.PickResultType.COMPLETE,\n        subchannel: pickedSubchannel,\n        status: null\n      };\n    }\n    /**\n     * Check what the next subchannel returned would be. Used by the load\n     * balancer implementation to preserve this part of the picker state if\n     * possible when a subchannel connects or disconnects.\n     */\n\n  }, {\n    key: \"peekNextSubchannel\",\n    value: function peekNextSubchannel() {\n      return this.subchannelList[this.nextIndex];\n    }\n  }]);\n\n  return RoundRobinPicker;\n}();\n\nvar RoundRobinLoadBalancer =\n/*#__PURE__*/\nfunction () {\n  function RoundRobinLoadBalancer(channelControlHelper) {\n    var _this$subchannelState,\n        _this = this;\n\n    _classCallCheck(this, RoundRobinLoadBalancer);\n\n    this.channelControlHelper = channelControlHelper;\n    this.subchannels = [];\n    this.currentState = channel_1.ConnectivityState.IDLE;\n    this.currentReadyPicker = null;\n    this.updateState(channel_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));\n    this.subchannelStateCounts = (_this$subchannelState = {}, _defineProperty(_this$subchannelState, channel_1.ConnectivityState.CONNECTING, 0), _defineProperty(_this$subchannelState, channel_1.ConnectivityState.IDLE, 0), _defineProperty(_this$subchannelState, channel_1.ConnectivityState.READY, 0), _defineProperty(_this$subchannelState, channel_1.ConnectivityState.SHUTDOWN, 0), _defineProperty(_this$subchannelState, channel_1.ConnectivityState.TRANSIENT_FAILURE, 0), _this$subchannelState);\n\n    this.subchannelStateListener = function (subchannel, previousState, newState) {\n      _this.subchannelStateCounts[previousState] -= 1;\n      _this.subchannelStateCounts[newState] += 1;\n\n      _this.calculateAndUpdateState();\n\n      if (newState === channel_1.ConnectivityState.TRANSIENT_FAILURE) {\n        _this.channelControlHelper.requestReresolution();\n      }\n\n      if (newState === channel_1.ConnectivityState.TRANSIENT_FAILURE || newState === channel_1.ConnectivityState.IDLE) {\n        subchannel.startConnecting();\n      }\n    };\n  }\n\n  _createClass(RoundRobinLoadBalancer, [{\n    key: \"calculateAndUpdateState\",\n    value: function calculateAndUpdateState() {\n      if (this.subchannelStateCounts[channel_1.ConnectivityState.READY] > 0) {\n        var readySubchannels = this.subchannels.filter(function (subchannel) {\n          return subchannel.getConnectivityState() === channel_1.ConnectivityState.READY;\n        });\n        var index = 0;\n\n        if (this.currentReadyPicker !== null) {\n          index = readySubchannels.indexOf(this.currentReadyPicker.peekNextSubchannel());\n\n          if (index < 0) {\n            index = 0;\n          }\n        }\n\n        this.updateState(channel_1.ConnectivityState.READY, new RoundRobinPicker(readySubchannels, index));\n      } else if (this.subchannelStateCounts[channel_1.ConnectivityState.CONNECTING] > 0) {\n        this.updateState(channel_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));\n      } else if (this.subchannelStateCounts[channel_1.ConnectivityState.TRANSIENT_FAILURE] > 0) {\n        this.updateState(channel_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker());\n      } else {\n        this.updateState(channel_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));\n      }\n    }\n  }, {\n    key: \"updateState\",\n    value: function updateState(newState, picker) {\n      if (newState === channel_1.ConnectivityState.READY) {\n        this.currentReadyPicker = picker;\n      } else {\n        this.currentReadyPicker = null;\n      }\n\n      this.currentState = newState;\n      this.channelControlHelper.updateState(newState, picker);\n    }\n  }, {\n    key: \"resetSubchannelList\",\n    value: function resetSubchannelList() {\n      var _this$subchannelState2;\n\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = this.subchannels[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var subchannel = _step.value;\n          subchannel.removeConnectivityStateListener(this.subchannelStateListener);\n          subchannel.unref();\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      this.subchannelStateCounts = (_this$subchannelState2 = {}, _defineProperty(_this$subchannelState2, channel_1.ConnectivityState.CONNECTING, 0), _defineProperty(_this$subchannelState2, channel_1.ConnectivityState.IDLE, 0), _defineProperty(_this$subchannelState2, channel_1.ConnectivityState.READY, 0), _defineProperty(_this$subchannelState2, channel_1.ConnectivityState.SHUTDOWN, 0), _defineProperty(_this$subchannelState2, channel_1.ConnectivityState.TRANSIENT_FAILURE, 0), _this$subchannelState2);\n      this.subchannels = [];\n    }\n  }, {\n    key: \"updateAddressList\",\n    value: function updateAddressList(addressList, lbConfig) {\n      var _this2 = this;\n\n      this.resetSubchannelList();\n      this.subchannels = addressList.map(function (address) {\n        return _this2.channelControlHelper.createSubchannel(address, {});\n      });\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = this.subchannels[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var subchannel = _step2.value;\n          var subchannelState = subchannel.getConnectivityState();\n          this.subchannelStateCounts[subchannelState] += 1;\n\n          if (subchannelState === channel_1.ConnectivityState.IDLE || subchannelState === channel_1.ConnectivityState.TRANSIENT_FAILURE) {\n            subchannel.startConnecting();\n          }\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      this.calculateAndUpdateState();\n    }\n  }, {\n    key: \"exitIdle\",\n    value: function exitIdle() {\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = this.subchannels[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var subchannel = _step3.value;\n          subchannel.startConnecting();\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"resetBackoff\",\n    value: function resetBackoff() {\n      /* The pick first load balancer does not have a connection backoff, so this\n       * does nothing */\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.resetSubchannelList();\n    }\n  }, {\n    key: \"getTypeName\",\n    value: function getTypeName() {\n      return TYPE_NAME;\n    }\n  }, {\n    key: \"replaceChannelControlHelper\",\n    value: function replaceChannelControlHelper(channelControlHelper) {\n      this.channelControlHelper = channelControlHelper;\n    }\n  }]);\n\n  return RoundRobinLoadBalancer;\n}();\n\nexports.RoundRobinLoadBalancer = RoundRobinLoadBalancer;\n\nfunction setup() {\n  load_balancer_1.registerLoadBalancerType(TYPE_NAME, RoundRobinLoadBalancer);\n}\n\nexports.setup = setup;","map":null,"metadata":{},"sourceType":"script"}