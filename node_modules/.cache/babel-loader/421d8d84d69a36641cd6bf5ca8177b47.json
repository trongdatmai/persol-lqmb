{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nvar _classCallCheck = require(\"/Users/maidat/Desktop/team-lq/persol-lqmb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/maidat/Desktop/team-lq/persol-lqmb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar channel_options_1 = require(\"./channel-options\");\n\nvar subchannel_1 = require(\"./subchannel\"); // 10 seconds in milliseconds. This value is arbitrary.\n\n/**\n * The amount of time in between checks for dropping subchannels that have no\n * other references\n */\n\n\nvar REF_CHECK_INTERVAL = 10000;\n\nvar SubchannelPool =\n/*#__PURE__*/\nfunction () {\n  /**\n   * A pool of subchannels use for making connections. Subchannels with the\n   * exact same parameters will be reused.\n   * @param global If true, this is the global subchannel pool. Otherwise, it\n   * is the pool for a single channel.\n   */\n  function SubchannelPool(global) {\n    _classCallCheck(this, SubchannelPool);\n\n    this.global = global;\n    this.pool = Object.create(null);\n    /**\n     * A timer of a task performing a periodic subchannel cleanup.\n     */\n\n    this.cleanupTimer = null;\n  }\n  /**\n   * Unrefs all unused subchannels and cancels the cleanup task if all\n   * subchannels have been unrefed.\n   */\n\n\n  _createClass(SubchannelPool, [{\n    key: \"unrefUnusedSubchannels\",\n    value: function unrefUnusedSubchannels() {\n      var allSubchannelsUnrefed = true;\n      /* These objects are created with Object.create(null), so they do not\n       * have a prototype, which means that for (... in ...) loops over them\n       * do not need to be filtered */\n      // tslint:disable-next-line:forin\n\n      for (var channelTarget in this.pool) {\n        // tslint:disable-next-line:forin\n        for (var subchannelTarget in this.pool[channelTarget]) {\n          var subchannelObjArray = this.pool[channelTarget][subchannelTarget];\n          var refedSubchannels = subchannelObjArray.filter(function (value) {\n            return !value.subchannel.unrefIfOneRef();\n          });\n\n          if (refedSubchannels.length > 0) {\n            allSubchannelsUnrefed = false;\n          }\n          /* For each subchannel in the pool, try to unref it if it has\n           * exactly one ref (which is the ref from the pool itself). If that\n           * does happen, remove the subchannel from the pool */\n\n\n          this.pool[channelTarget][subchannelTarget] = refedSubchannels;\n        }\n      }\n      /* Currently we do not delete keys with empty values. If that results\n       * in significant memory usage we should change it. */\n      // Cancel the cleanup task if all subchannels have been unrefed.\n\n\n      if (allSubchannelsUnrefed && this.cleanupTimer !== null) {\n        clearInterval(this.cleanupTimer);\n        this.cleanupTimer = null;\n      }\n    }\n    /**\n     * Ensures that the cleanup task is spawned.\n     */\n\n  }, {\n    key: \"ensureCleanupTask\",\n    value: function ensureCleanupTask() {\n      var _this = this;\n\n      if (this.global && this.cleanupTimer === null) {\n        this.cleanupTimer = setInterval(function () {\n          _this.unrefUnusedSubchannels();\n        }, REF_CHECK_INTERVAL); // Unref because this timer should not keep the event loop running.\n\n        this.cleanupTimer.unref();\n      }\n    }\n    /**\n     * Get a subchannel if one already exists with exactly matching parameters.\n     * Otherwise, create and save a subchannel with those parameters.\n     * @param channelTarget\n     * @param subchannelTarget\n     * @param channelArguments\n     * @param channelCredentials\n     */\n\n  }, {\n    key: \"getOrCreateSubchannel\",\n    value: function getOrCreateSubchannel(channelTarget, subchannelTarget, channelArguments, channelCredentials) {\n      this.ensureCleanupTask();\n\n      if (channelTarget in this.pool) {\n        if (subchannelTarget in this.pool[channelTarget]) {\n          var subchannelObjArray = this.pool[channelTarget][subchannelTarget];\n          var _iteratorNormalCompletion = true;\n          var _didIteratorError = false;\n          var _iteratorError = undefined;\n\n          try {\n            for (var _iterator = subchannelObjArray[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n              var subchannelObj = _step.value;\n\n              if (channel_options_1.channelOptionsEqual(channelArguments, subchannelObj.channelArguments) && channelCredentials._equals(subchannelObj.channelCredentials)) {\n                return subchannelObj.subchannel;\n              }\n            }\n          } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion && _iterator.return != null) {\n                _iterator.return();\n              }\n            } finally {\n              if (_didIteratorError) {\n                throw _iteratorError;\n              }\n            }\n          }\n        }\n      } // If we get here, no matching subchannel was found\n\n\n      var subchannel = new subchannel_1.Subchannel(channelTarget, subchannelTarget, channelArguments, channelCredentials);\n\n      if (!(channelTarget in this.pool)) {\n        this.pool[channelTarget] = Object.create(null);\n      }\n\n      if (!(subchannelTarget in this.pool[channelTarget])) {\n        this.pool[channelTarget][subchannelTarget] = [];\n      }\n\n      this.pool[channelTarget][subchannelTarget].push({\n        channelArguments: channelArguments,\n        channelCredentials: channelCredentials,\n        subchannel: subchannel\n      });\n\n      if (this.global) {\n        subchannel.ref();\n      }\n\n      return subchannel;\n    }\n  }]);\n\n  return SubchannelPool;\n}();\n\nexports.SubchannelPool = SubchannelPool;\nvar globalSubchannelPool = new SubchannelPool(true);\n/**\n * Get either the global subchannel pool, or a new subchannel pool.\n * @param global\n */\n\nfunction getSubchannelPool(global) {\n  if (global) {\n    return globalSubchannelPool;\n  } else {\n    return new SubchannelPool(false);\n  }\n}\n\nexports.getSubchannelPool = getSubchannelPool;","map":null,"metadata":{},"sourceType":"script"}