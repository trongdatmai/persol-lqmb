{"ast":null,"code":"var objectKeys = require('object-keys');\n\nvar isArguments = require('is-arguments');\n\nvar is = require('object-is');\n\nvar isRegex = require('is-regex');\n\nvar flags = require('regexp.prototype.flags');\n\nvar isArray = require('isarray');\n\nvar isDate = require('is-date-object');\n\nvar whichBoxedPrimitive = require('which-boxed-primitive');\n\nvar GetIntrinsic = require('es-abstract/GetIntrinsic');\n\nvar callBound = require('es-abstract/helpers/callBound');\n\nvar whichCollection = require('which-collection');\n\nvar getIterator = require('es-get-iterator');\n\nvar getSideChannel = require('side-channel');\n\nvar $getTime = callBound('Date.prototype.getTime');\nvar gPO = Object.getPrototypeOf;\nvar $objToString = callBound('Object.prototype.toString');\nvar $Set = GetIntrinsic('%Set%', true);\nvar $mapHas = callBound('Map.prototype.has', true);\nvar $mapGet = callBound('Map.prototype.get', true);\nvar $mapSize = callBound('Map.prototype.size', true);\nvar $setAdd = callBound('Set.prototype.add', true);\nvar $setDelete = callBound('Set.prototype.delete', true);\nvar $setHas = callBound('Set.prototype.has', true);\nvar $setSize = callBound('Set.prototype.size', true); // taken from https://github.com/browserify/commonjs-assert/blob/bba838e9ba9e28edf3127ce6974624208502f6bc/internal/util/comparisons.js#L401-L414\n\nfunction setHasEqualElement(set, val1, strict, channel) {\n  var i = getIterator(set);\n  var result;\n\n  while ((result = i.next()) && !result.done) {\n    if (internalDeepEqual(val1, result.value, strict, channel)) {\n      // eslint-disable-line no-use-before-define\n      // Remove the matching element to make sure we do not check that again.\n      $setDelete(set, result.value);\n      return true;\n    }\n  }\n\n  return false;\n} // taken from https://github.com/browserify/commonjs-assert/blob/bba838e9ba9e28edf3127ce6974624208502f6bc/internal/util/comparisons.js#L416-L439\n\n\nfunction findLooseMatchingPrimitives(prim) {\n  if (typeof prim === 'undefined') {\n    return null;\n  }\n\n  if (typeof prim === 'object') {\n    // Only pass in null as object!\n    return void 0;\n  }\n\n  if (typeof prim === 'symbol') {\n    return false;\n  }\n\n  if (typeof prim === 'string' || typeof prim === 'number') {\n    // Loose equal entries exist only if the string is possible to convert to a regular number and not NaN.\n    return +prim === +prim; // eslint-disable-line no-implicit-coercion\n  }\n\n  return true;\n} // taken from https://github.com/browserify/commonjs-assert/blob/bba838e9ba9e28edf3127ce6974624208502f6bc/internal/util/comparisons.js#L449-L460\n\n\nfunction mapMightHaveLoosePrim(a, b, prim, item, channel) {\n  var altValue = findLooseMatchingPrimitives(prim);\n\n  if (altValue != null) {\n    return altValue;\n  }\n\n  var curB = $mapGet(b, altValue); // eslint-disable-next-line no-use-before-define\n\n  if (typeof curB === 'undefined' && !$mapHas(b, altValue) || !internalDeepEqual(item, curB, false, channel)) {\n    return false;\n  } // eslint-disable-next-line no-use-before-define\n\n\n  return !$mapHas(a, altValue) && internalDeepEqual(item, curB, false, channel);\n} // taken from https://github.com/browserify/commonjs-assert/blob/bba838e9ba9e28edf3127ce6974624208502f6bc/internal/util/comparisons.js#L441-L447\n\n\nfunction setMightHaveLoosePrim(a, b, prim) {\n  var altValue = findLooseMatchingPrimitives(prim);\n\n  if (altValue != null) {\n    return altValue;\n  }\n\n  return $setHas(b, altValue) && !$setHas(a, altValue);\n} // taken from https://github.com/browserify/commonjs-assert/blob/bba838e9ba9e28edf3127ce6974624208502f6bc/internal/util/comparisons.js#L518-L533\n\n\nfunction mapHasEqualEntry(set, map, key1, item1, strict, channel) {\n  var i = getIterator(set);\n  var result;\n  var key2;\n\n  while ((result = i.next()) && !result.done) {\n    key2 = result.value;\n\n    if ( // eslint-disable-next-line no-use-before-define\n    internalDeepEqual(key1, key2, strict, channel) // eslint-disable-next-line no-use-before-define\n    && internalDeepEqual(item1, $mapGet(map, key2), strict, channel)) {\n      $setDelete(set, key2);\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction internalDeepEqual(actual, expected, options, channel) {\n  var opts = options || {}; // 7.1. All identical values are equivalent, as determined by ===.\n\n  if (opts.strict ? is(actual, expected) : actual === expected) {\n    return true;\n  }\n\n  var actualBoxed = whichBoxedPrimitive(actual);\n  var expectedBoxed = whichBoxedPrimitive(expected);\n\n  if (actualBoxed !== expectedBoxed) {\n    return false;\n  } // 7.3. Other pairs that do not both pass typeof value == 'object', equivalence is determined by ==.\n\n\n  if (!actual || !expected || typeof actual !== 'object' && typeof expected !== 'object') {\n    if (actual === false && expected || actual && expected === false) {\n      return false;\n    }\n\n    return opts.strict ? is(actual, expected) : actual == expected; // eslint-disable-line eqeqeq\n  }\n  /*\n   * 7.4. For all other Object pairs, including Array objects, equivalence is\n   * determined by having the same number of owned properties (as verified\n   * with Object.prototype.hasOwnProperty.call), the same set of keys\n   * (although not necessarily the same order), equivalent values for every\n   * corresponding key, and an identical 'prototype' property. Note: this\n   * accounts for both named and indexed properties on Arrays.\n   */\n  // see https://github.com/nodejs/node/commit/d3aafd02efd3a403d646a3044adcf14e63a88d32 for memos/channel inspiration\n\n\n  var hasActual = channel.has(actual);\n  var hasExpected = channel.has(expected);\n  var sentinel;\n\n  if (hasActual && hasExpected) {\n    if (channel.get(actual) === channel.get(expected)) {\n      return true;\n    }\n  } else {\n    sentinel = {};\n  }\n\n  if (!hasActual) {\n    channel.set(actual, sentinel);\n  }\n\n  if (!hasExpected) {\n    channel.set(expected, sentinel);\n  } // eslint-disable-next-line no-use-before-define\n\n\n  return objEquiv(actual, expected, opts, channel);\n}\n\nfunction isBuffer(x) {\n  if (!x || typeof x !== 'object' || typeof x.length !== 'number') {\n    return false;\n  }\n\n  if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {\n    return false;\n  }\n\n  if (x.length > 0 && typeof x[0] !== 'number') {\n    return false;\n  }\n\n  return true;\n}\n\nfunction setEquiv(a, b, opts, channel) {\n  if ($setSize(a) !== $setSize(b)) {\n    return false;\n  }\n\n  var iA = getIterator(a);\n  var iB = getIterator(b);\n  var resultA;\n  var resultB;\n  var set;\n\n  while ((resultA = iA.next()) && !resultA.done) {\n    if (resultA.value && typeof resultA.value === 'object') {\n      if (!set) {\n        set = new $Set();\n      }\n\n      $setAdd(set, resultA.value);\n    } else if (!$setHas(b, resultA.value)) {\n      if (opts.strict) {\n        return false;\n      }\n\n      if (!setMightHaveLoosePrim(a, b, resultA.value)) {\n        return false;\n      }\n\n      if (!set) {\n        set = new $Set();\n      }\n\n      $setAdd(set, resultA.value);\n    }\n  }\n\n  if (set) {\n    while ((resultB = iB.next()) && !resultB.done) {\n      // We have to check if a primitive value is already matching and only if it's not, go hunting for it.\n      if (resultB.value && typeof resultB.value === 'object') {\n        if (!setHasEqualElement(set, resultB.value, opts.strict, channel)) {\n          return false;\n        }\n      } else if (!opts.strict && !$setHas(a, resultB.value) && !setHasEqualElement(set, resultB.value, opts.strict, channel)) {\n        return false;\n      }\n    }\n\n    return $setSize(set) === 0;\n  }\n\n  return true;\n}\n\nfunction mapEquiv(a, b, opts, channel) {\n  if ($mapSize(a) !== $mapSize(b)) {\n    return false;\n  }\n\n  var iA = getIterator(a);\n  var iB = getIterator(b);\n  var resultA;\n  var resultB;\n  var set;\n  var key;\n  var item1;\n  var item2;\n\n  while ((resultA = iA.next()) && !resultA.done) {\n    key = resultA.value[0];\n    item1 = resultA.value[1];\n\n    if (key && typeof key === 'object') {\n      if (!set) {\n        set = new $Set();\n      }\n\n      $setAdd(set, key);\n    } else {\n      item2 = $mapGet(b, key); // if (typeof curB === 'undefined' && !$mapHas(b, altValue) || !internalDeepEqual(item, curB, false, channel)) {\n\n      if (typeof item2 === 'undefined' && !$mapHas(b, key) || !internalDeepEqual(item1, item2, opts.strict, channel)) {\n        if (opts.strict) {\n          return false;\n        }\n\n        if (!mapMightHaveLoosePrim(a, b, key, item1, channel)) {\n          return false;\n        }\n\n        if (!set) {\n          set = new $Set();\n        }\n\n        $setAdd(set, key);\n      }\n    }\n  }\n\n  if (set) {\n    while ((resultB = iB.next()) && !resultB.done) {\n      key = resultB.value[0];\n      item1 = resultB.value[1];\n\n      if (key && typeof key === 'object') {\n        if (!mapHasEqualEntry(set, a, key, item1, opts.strict, channel)) {\n          return false;\n        }\n      } else if (!opts.strict && (!a.has(key) || !internalDeepEqual($mapGet(a, key), item1, false, channel)) && !mapHasEqualEntry(set, a, key, item1, false, channel)) {\n        return false;\n      }\n    }\n\n    return $setSize(set) === 0;\n  }\n\n  return true;\n}\n\nfunction objEquiv(a, b, opts, channel) {\n  /* eslint max-statements: [2, 100], max-lines-per-function: [2, 120], max-depth: [2, 5] */\n  var i, key;\n\n  if (typeof a !== typeof b) {\n    return false;\n  }\n\n  if (a == null || b == null) {\n    return false;\n  } // an identical 'prototype' property.\n\n\n  if (a.prototype !== b.prototype) {\n    return false;\n  }\n\n  if ($objToString(a) !== $objToString(b)) {\n    return false;\n  }\n\n  if (isArguments(a) !== isArguments(b)) {\n    return false;\n  }\n\n  var aIsArray = isArray(a);\n  var bIsArray = isArray(b);\n\n  if (aIsArray !== bIsArray) {\n    return false;\n  } // TODO: replace when a cross-realm brand check is available\n\n\n  var aIsError = a instanceof Error;\n  var bIsError = b instanceof Error;\n\n  if (aIsError !== bIsError) {\n    return false;\n  }\n\n  if (aIsError || bIsError) {\n    if (a.name !== b.name || a.message !== b.message) {\n      return false;\n    }\n  }\n\n  var aIsRegex = isRegex(a);\n  var bIsRegex = isRegex(b);\n\n  if (aIsRegex !== bIsRegex) {\n    return false;\n  }\n\n  if ((aIsRegex || bIsRegex) && (a.source !== b.source || flags(a) !== flags(b))) {\n    return false;\n  }\n\n  var aIsDate = isDate(a);\n  var bIsDate = isDate(b);\n\n  if (aIsDate !== bIsDate) {\n    return false;\n  }\n\n  if (aIsDate || bIsDate) {\n    // && would work too, because both are true or both false here\n    if ($getTime(a) !== $getTime(b)) {\n      return false;\n    }\n  }\n\n  if (opts.strict && gPO && gPO(a) !== gPO(b)) {\n    return false;\n  }\n\n  var aIsBuffer = isBuffer(a);\n  var bIsBuffer = isBuffer(b);\n\n  if (aIsBuffer !== bIsBuffer) {\n    return false;\n  }\n\n  if (aIsBuffer || bIsBuffer) {\n    // && would work too, because both are true or both false here\n    if (a.length !== b.length) {\n      return false;\n    }\n\n    for (i = 0; i < a.length; i++) {\n      if (a[i] !== b[i]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  if (typeof a !== typeof b) {\n    return false;\n  }\n\n  try {\n    var ka = objectKeys(a);\n    var kb = objectKeys(b);\n  } catch (e) {\n    // happens when one is a string literal and the other isn't\n    return false;\n  } // having the same number of owned properties (keys incorporates hasOwnProperty)\n\n\n  if (ka.length !== kb.length) {\n    return false;\n  } // the same set of keys (although not necessarily the same order),\n\n\n  ka.sort();\n  kb.sort(); // ~~~cheap key test\n\n  for (i = ka.length - 1; i >= 0; i--) {\n    if (ka[i] != kb[i]) {\n      return false;\n    } // eslint-disable-line eqeqeq\n\n  } // equivalent values for every corresponding key, and ~~~possibly expensive deep test\n\n\n  for (i = ka.length - 1; i >= 0; i--) {\n    key = ka[i];\n\n    if (!internalDeepEqual(a[key], b[key], opts, channel)) {\n      return false;\n    }\n  }\n\n  var aCollection = whichCollection(a);\n  var bCollection = whichCollection(b);\n\n  if (aCollection !== bCollection) {\n    return false;\n  }\n\n  if (aCollection === 'Set' || bCollection === 'Set') {\n    // aCollection === bCollection\n    return setEquiv(a, b, opts, channel);\n  }\n\n  if (aCollection === 'Map') {\n    // aCollection === bCollection\n    return mapEquiv(a, b, opts, channel);\n  }\n\n  return true;\n}\n\nmodule.exports = function deepEqual(a, b, opts) {\n  return internalDeepEqual(a, b, opts, getSideChannel());\n};","map":null,"metadata":{},"sourceType":"script"}