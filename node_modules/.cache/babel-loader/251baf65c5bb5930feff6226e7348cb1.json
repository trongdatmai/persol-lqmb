{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nvar _slicedToArray = require(\"/Users/maidat/Desktop/team-lq/persol-lqmb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _defineProperty = require(\"/Users/maidat/Desktop/team-lq/persol-lqmb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/defineProperty\");\n\nvar _classCallCheck = require(\"/Users/maidat/Desktop/team-lq/persol-lqmb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/maidat/Desktop/team-lq/persol-lqmb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar load_balancer_1 = require(\"./load-balancer\");\n\nvar channel_1 = require(\"./channel\");\n\nvar picker_1 = require(\"./picker\");\n\nvar logging = require(\"./logging\");\n\nvar constants_1 = require(\"./constants\");\n\nvar TRACER_NAME = 'pick_first';\n\nfunction trace(text) {\n  logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\n\nvar TYPE_NAME = 'pick_first';\n/**\n * Delay after starting a connection on a subchannel before starting a\n * connection on the next subchannel in the list, for Happy Eyeballs algorithm.\n */\n\nvar CONNECTION_DELAY_INTERVAL_MS = 250;\n/**\n * Picker for a `PickFirstLoadBalancer` in the READY state. Always returns the\n * picked subchannel.\n */\n\nvar PickFirstPicker =\n/*#__PURE__*/\nfunction () {\n  function PickFirstPicker(subchannel) {\n    _classCallCheck(this, PickFirstPicker);\n\n    this.subchannel = subchannel;\n  }\n\n  _createClass(PickFirstPicker, [{\n    key: \"pick\",\n    value: function pick(pickArgs) {\n      return {\n        pickResultType: picker_1.PickResultType.COMPLETE,\n        subchannel: this.subchannel,\n        status: null\n      };\n    }\n  }]);\n\n  return PickFirstPicker;\n}();\n\nvar PickFirstLoadBalancer =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Load balancer that attempts to connect to each backend in the address list\n   * in order, and picks the first one that connects, using it for every\n   * request.\n   * @param channelControlHelper `ChannelControlHelper` instance provided by\n   *     this load balancer's owner.\n   */\n  function PickFirstLoadBalancer(channelControlHelper) {\n    var _this$subchannelState,\n        _this = this;\n\n    _classCallCheck(this, PickFirstLoadBalancer);\n\n    this.channelControlHelper = channelControlHelper;\n    /**\n     * The list of backend addresses most recently passed to `updateAddressList`.\n     */\n\n    this.latestAddressList = [];\n    /**\n     * The list of subchannels this load balancer is currently attempting to\n     * connect to.\n     */\n\n    this.subchannels = [];\n    /**\n     * The current connectivity state of the load balancer.\n     */\n\n    this.currentState = channel_1.ConnectivityState.IDLE;\n    /**\n     * The index within the `subchannels` array of the subchannel with the most\n     * recently started connection attempt.\n     */\n\n    this.currentSubchannelIndex = 0;\n    /**\n     * The currently picked subchannel used for making calls. Populated if\n     * and only if the load balancer's current state is READY. In that case,\n     * the subchannel's current state is also READY.\n     */\n\n    this.currentPick = null;\n    this.triedAllSubchannels = false;\n    this.updateState(channel_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));\n    this.subchannelStateCounts = (_this$subchannelState = {}, _defineProperty(_this$subchannelState, channel_1.ConnectivityState.CONNECTING, 0), _defineProperty(_this$subchannelState, channel_1.ConnectivityState.IDLE, 0), _defineProperty(_this$subchannelState, channel_1.ConnectivityState.READY, 0), _defineProperty(_this$subchannelState, channel_1.ConnectivityState.SHUTDOWN, 0), _defineProperty(_this$subchannelState, channel_1.ConnectivityState.TRANSIENT_FAILURE, 0), _this$subchannelState);\n\n    this.subchannelStateListener = function (subchannel, previousState, newState) {\n      _this.subchannelStateCounts[previousState] -= 1;\n      _this.subchannelStateCounts[newState] += 1;\n      /* If the subchannel we most recently attempted to start connecting\n       * to goes into TRANSIENT_FAILURE, immediately try to start\n       * connecting to the next one instead of waiting for the connection\n       * delay timer. */\n\n      if (subchannel === _this.subchannels[_this.currentSubchannelIndex] && newState === channel_1.ConnectivityState.TRANSIENT_FAILURE) {\n        _this.startNextSubchannelConnecting();\n      }\n\n      if (newState === channel_1.ConnectivityState.READY) {\n        _this.pickSubchannel(subchannel);\n\n        return;\n      } else {\n        if (_this.triedAllSubchannels && _this.subchannelStateCounts[channel_1.ConnectivityState.IDLE] === _this.subchannels.length) {\n          /* If all of the subchannels are IDLE we should go back to a\n           * basic IDLE state where there is no subchannel list to avoid\n           * holding unused resources */\n          _this.resetSubchannelList();\n        }\n\n        if (_this.currentPick === null) {\n          if (_this.triedAllSubchannels) {\n            var newLBState;\n\n            if (_this.subchannelStateCounts[channel_1.ConnectivityState.CONNECTING] > 0) {\n              newLBState = channel_1.ConnectivityState.CONNECTING;\n            } else if (_this.subchannelStateCounts[channel_1.ConnectivityState.TRANSIENT_FAILURE] > 0) {\n              newLBState = channel_1.ConnectivityState.TRANSIENT_FAILURE;\n            } else {\n              newLBState = channel_1.ConnectivityState.IDLE;\n            }\n\n            if (newLBState !== _this.currentState) {\n              if (newLBState === channel_1.ConnectivityState.TRANSIENT_FAILURE) {\n                _this.updateState(newLBState, new picker_1.UnavailablePicker());\n              } else {\n                _this.updateState(newLBState, new picker_1.QueuePicker(_this));\n              }\n            }\n          } else {\n            _this.updateState(channel_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(_this));\n          }\n        }\n      }\n    };\n\n    this.pickedSubchannelStateListener = function (subchannel, previousState, newState) {\n      if (newState !== channel_1.ConnectivityState.READY) {\n        _this.currentPick = null;\n        subchannel.unref();\n        subchannel.removeConnectivityStateListener(_this.pickedSubchannelStateListener);\n\n        if (_this.subchannels.length > 0) {\n          if (_this.triedAllSubchannels) {\n            var newLBState;\n\n            if (_this.subchannelStateCounts[channel_1.ConnectivityState.CONNECTING] > 0) {\n              newLBState = channel_1.ConnectivityState.CONNECTING;\n            } else if (_this.subchannelStateCounts[channel_1.ConnectivityState.TRANSIENT_FAILURE] > 0) {\n              newLBState = channel_1.ConnectivityState.TRANSIENT_FAILURE;\n            } else {\n              newLBState = channel_1.ConnectivityState.IDLE;\n            }\n\n            if (newLBState === channel_1.ConnectivityState.TRANSIENT_FAILURE) {\n              _this.updateState(newLBState, new picker_1.UnavailablePicker());\n            } else {\n              _this.updateState(newLBState, new picker_1.QueuePicker(_this));\n            }\n          } else {\n            _this.updateState(channel_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(_this));\n          }\n        } else {\n          /* We don't need to backoff here because this only happens if a\n           * subchannel successfully connects then disconnects, so it will not\n           * create a loop of attempting to connect to an unreachable backend\n           */\n          _this.updateState(channel_1.ConnectivityState.IDLE, new picker_1.QueuePicker(_this));\n        }\n      }\n    };\n\n    this.connectionDelayTimeout = setTimeout(function () {}, 0);\n    clearTimeout(this.connectionDelayTimeout);\n  }\n\n  _createClass(PickFirstLoadBalancer, [{\n    key: \"startNextSubchannelConnecting\",\n    value: function startNextSubchannelConnecting() {\n      if (this.triedAllSubchannels) {\n        return;\n      }\n\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = this.subchannels.entries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var _ref3 = _step.value;\n\n          var _ref2 = _slicedToArray(_ref3, 2);\n\n          var index = _ref2[0];\n          var subchannel = _ref2[1];\n\n          if (index > this.currentSubchannelIndex) {\n            var subchannelState = subchannel.getConnectivityState();\n\n            if (subchannelState === channel_1.ConnectivityState.IDLE || subchannelState === channel_1.ConnectivityState.CONNECTING) {\n              this.startConnecting(index);\n              return;\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      this.triedAllSubchannels = true;\n    }\n    /**\n     * Have a single subchannel in the `subchannels` list start connecting.\n     * @param subchannelIndex The index into the `subchannels` list.\n     */\n\n  }, {\n    key: \"startConnecting\",\n    value: function startConnecting(subchannelIndex) {\n      var _this2 = this;\n\n      clearTimeout(this.connectionDelayTimeout);\n      this.currentSubchannelIndex = subchannelIndex;\n\n      if (this.subchannels[subchannelIndex].getConnectivityState() === channel_1.ConnectivityState.IDLE) {\n        trace('Start connecting to subchannel with address ' + this.subchannels[subchannelIndex].getAddress());\n        process.nextTick(function () {\n          _this2.subchannels[subchannelIndex].startConnecting();\n        });\n      }\n\n      this.connectionDelayTimeout = setTimeout(function () {\n        _this2.startNextSubchannelConnecting();\n      }, CONNECTION_DELAY_INTERVAL_MS);\n    }\n  }, {\n    key: \"pickSubchannel\",\n    value: function pickSubchannel(subchannel) {\n      trace('Pick subchannel with address ' + subchannel.getAddress());\n\n      if (this.currentPick !== null) {\n        this.currentPick.unref();\n        this.currentPick.removeConnectivityStateListener(this.pickedSubchannelStateListener);\n      }\n\n      this.currentPick = subchannel;\n      this.updateState(channel_1.ConnectivityState.READY, new PickFirstPicker(subchannel));\n      subchannel.addConnectivityStateListener(this.pickedSubchannelStateListener);\n      subchannel.ref();\n      this.resetSubchannelList();\n      clearTimeout(this.connectionDelayTimeout);\n    }\n  }, {\n    key: \"updateState\",\n    value: function updateState(newState, picker) {\n      trace(channel_1.ConnectivityState[this.currentState] + ' -> ' + channel_1.ConnectivityState[newState]);\n      this.currentState = newState;\n      this.channelControlHelper.updateState(newState, picker);\n    }\n  }, {\n    key: \"resetSubchannelList\",\n    value: function resetSubchannelList() {\n      var _this$subchannelState2;\n\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = this.subchannels[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var subchannel = _step2.value;\n          subchannel.removeConnectivityStateListener(this.subchannelStateListener);\n          subchannel.unref();\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      this.currentSubchannelIndex = 0;\n      this.subchannelStateCounts = (_this$subchannelState2 = {}, _defineProperty(_this$subchannelState2, channel_1.ConnectivityState.CONNECTING, 0), _defineProperty(_this$subchannelState2, channel_1.ConnectivityState.IDLE, 0), _defineProperty(_this$subchannelState2, channel_1.ConnectivityState.READY, 0), _defineProperty(_this$subchannelState2, channel_1.ConnectivityState.SHUTDOWN, 0), _defineProperty(_this$subchannelState2, channel_1.ConnectivityState.TRANSIENT_FAILURE, 0), _this$subchannelState2);\n      this.subchannels = [];\n      this.triedAllSubchannels = false;\n    }\n    /**\n     * Start connecting to the address list most recently passed to\n     * `updateAddressList`.\n     */\n\n  }, {\n    key: \"connectToAddressList\",\n    value: function connectToAddressList() {\n      var _this3 = this;\n\n      this.resetSubchannelList();\n      trace('Connect to address list ' + this.latestAddressList);\n      this.subchannels = this.latestAddressList.map(function (address) {\n        return _this3.channelControlHelper.createSubchannel(address, {});\n      });\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = this.subchannels[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var subchannel = _step3.value;\n          subchannel.ref();\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n\n      var _iteratorNormalCompletion4 = true;\n      var _didIteratorError4 = false;\n      var _iteratorError4 = undefined;\n\n      try {\n        for (var _iterator4 = this.subchannels[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n          var _subchannel = _step4.value;\n\n          _subchannel.addConnectivityStateListener(this.subchannelStateListener);\n\n          if (_subchannel.getConnectivityState() === channel_1.ConnectivityState.READY) {\n            this.pickSubchannel(_subchannel);\n            this.resetSubchannelList();\n            return;\n          }\n        }\n      } catch (err) {\n        _didIteratorError4 = true;\n        _iteratorError4 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n            _iterator4.return();\n          }\n        } finally {\n          if (_didIteratorError4) {\n            throw _iteratorError4;\n          }\n        }\n      }\n\n      var _iteratorNormalCompletion5 = true;\n      var _didIteratorError5 = false;\n      var _iteratorError5 = undefined;\n\n      try {\n        for (var _iterator5 = this.subchannels.entries()[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n          var _ref6 = _step5.value;\n\n          var _ref5 = _slicedToArray(_ref6, 2);\n\n          var index = _ref5[0];\n          var _subchannel2 = _ref5[1];\n\n          var subchannelState = _subchannel2.getConnectivityState();\n\n          if (subchannelState === channel_1.ConnectivityState.IDLE || subchannelState === channel_1.ConnectivityState.CONNECTING) {\n            this.startConnecting(index);\n\n            if (this.currentPick === null) {\n              this.updateState(channel_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));\n            }\n\n            return;\n          }\n        } // If the code reaches this point, every subchannel must be in TRANSIENT_FAILURE\n\n      } catch (err) {\n        _didIteratorError5 = true;\n        _iteratorError5 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion5 && _iterator5.return != null) {\n            _iterator5.return();\n          }\n        } finally {\n          if (_didIteratorError5) {\n            throw _iteratorError5;\n          }\n        }\n      }\n\n      if (this.currentPick === null) {\n        this.updateState(channel_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker());\n      }\n    }\n  }, {\n    key: \"updateAddressList\",\n    value: function updateAddressList(addressList, lbConfig) {\n      // lbConfig has no useful information for pick first load balancing\n\n      /* To avoid unnecessary churn, we only do something with this address list\n       * if we're not currently trying to establish a connection, or if the new\n       * address list is different from the existing one */\n      if (this.subchannels.length === 0 || !this.latestAddressList.every(function (value, index) {\n        return addressList[index] === value;\n      })) {\n        this.latestAddressList = addressList;\n        this.connectToAddressList();\n      }\n    }\n  }, {\n    key: \"exitIdle\",\n    value: function exitIdle() {\n      var _iteratorNormalCompletion6 = true;\n      var _didIteratorError6 = false;\n      var _iteratorError6 = undefined;\n\n      try {\n        for (var _iterator6 = this.subchannels[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n          var subchannel = _step6.value;\n          subchannel.startConnecting();\n        }\n      } catch (err) {\n        _didIteratorError6 = true;\n        _iteratorError6 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion6 && _iterator6.return != null) {\n            _iterator6.return();\n          }\n        } finally {\n          if (_didIteratorError6) {\n            throw _iteratorError6;\n          }\n        }\n      }\n\n      if (this.currentState === channel_1.ConnectivityState.IDLE) {\n        if (this.latestAddressList.length > 0) {\n          this.connectToAddressList();\n        }\n      }\n\n      if (this.currentState === channel_1.ConnectivityState.IDLE || this.triedAllSubchannels) {\n        this.channelControlHelper.requestReresolution();\n      }\n    }\n  }, {\n    key: \"resetBackoff\",\n    value: function resetBackoff() {\n      /* The pick first load balancer does not have a connection backoff, so this\n       * does nothing */\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.resetSubchannelList();\n\n      if (this.currentPick !== null) {\n        this.currentPick.unref();\n        this.currentPick.removeConnectivityStateListener(this.pickedSubchannelStateListener);\n      }\n    }\n  }, {\n    key: \"getTypeName\",\n    value: function getTypeName() {\n      return TYPE_NAME;\n    }\n  }, {\n    key: \"replaceChannelControlHelper\",\n    value: function replaceChannelControlHelper(channelControlHelper) {\n      this.channelControlHelper = channelControlHelper;\n    }\n  }]);\n\n  return PickFirstLoadBalancer;\n}();\n\nexports.PickFirstLoadBalancer = PickFirstLoadBalancer;\n\nfunction setup() {\n  load_balancer_1.registerLoadBalancerType(TYPE_NAME, PickFirstLoadBalancer);\n}\n\nexports.setup = setup;","map":null,"metadata":{},"sourceType":"script"}