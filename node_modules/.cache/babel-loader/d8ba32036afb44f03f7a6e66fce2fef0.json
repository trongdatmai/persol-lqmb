{"ast":null,"code":"\"use strict\";\n/*!\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar _regeneratorRuntime = require(\"/Users/maidat/Desktop/team-lq/persol-lqmb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/maidat/Desktop/team-lq/persol-lqmb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/maidat/Desktop/team-lq/persol-lqmb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/maidat/Desktop/team-lq/persol-lqmb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/Users/maidat/Desktop/team-lq/persol-lqmb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/Users/maidat/Desktop/team-lq/persol-lqmb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _assertThisInitialized = require(\"/Users/maidat/Desktop/team-lq/persol-lqmb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar _inherits = require(\"/Users/maidat/Desktop/team-lq/persol-lqmb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar abort_controller_1 = require(\"abort-controller\");\n\nvar ConfigStore = require(\"configstore\");\n\nvar crypto_1 = require(\"crypto\");\n\nvar google_auth_library_1 = require(\"google-auth-library\");\n\nvar Pumpify = require(\"pumpify\");\n\nvar stream_1 = require(\"stream\");\n\nvar streamEvents = require(\"stream-events\");\n\nvar TERMINATED_UPLOAD_STATUS_CODE = 410;\nvar RESUMABLE_INCOMPLETE_STATUS_CODE = 308;\nvar RETRY_LIMIT = 5;\n\nvar Upload =\n/*#__PURE__*/\nfunction (_Pumpify) {\n  _inherits(Upload, _Pumpify);\n\n  function Upload(cfg) {\n    var _this;\n\n    _classCallCheck(this, Upload);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Upload).call(this));\n    _this.numBytesWritten = 0;\n    _this.numRetries = 0;\n    streamEvents(_assertThisInitialized(_this));\n    cfg = cfg || {};\n\n    if (!cfg.bucket || !cfg.file) {\n      throw new Error('A bucket and file name are required');\n    }\n\n    cfg.authConfig = cfg.authConfig || {};\n    cfg.authConfig.scopes = ['https://www.googleapis.com/auth/devstorage.full_control'];\n    _this.authClient = cfg.authClient || new google_auth_library_1.GoogleAuth(cfg.authConfig);\n    _this.apiEndpoint = cfg.apiEndpoint || 'storage.googleapis.com';\n    _this.bucket = cfg.bucket;\n    var cacheKeyElements = [cfg.bucket, cfg.file];\n\n    if (typeof cfg.generation === 'number') {\n      cacheKeyElements.push(\"\".concat(cfg.generation));\n    }\n\n    _this.cacheKey = cacheKeyElements.join('/');\n    _this.file = cfg.file;\n    _this.generation = cfg.generation;\n    _this.kmsKeyName = cfg.kmsKeyName;\n    _this.metadata = cfg.metadata || {};\n    _this.offset = cfg.offset;\n    _this.origin = cfg.origin;\n    _this.params = cfg.params || {};\n    _this.userProject = cfg.userProject;\n\n    if (cfg.key) {\n      /**\n       * NOTE: This is `as string` because there appears to be some weird kind\n       * of TypeScript bug as 2.8. Tracking the issue here:\n       * https://github.com/Microsoft/TypeScript/issues/23155\n       */\n      var base64Key = Buffer.from(cfg.key).toString('base64');\n      _this.encryption = {\n        key: base64Key,\n        hash: crypto_1.createHash('sha256').update(cfg.key).digest('base64')\n      };\n    }\n\n    _this.predefinedAcl = cfg.predefinedAcl;\n    if (cfg.private) _this.predefinedAcl = 'private';\n    if (cfg.public) _this.predefinedAcl = 'publicRead';\n    var configPath = cfg.configPath;\n    _this.configStore = new ConfigStore('gcs-resumable-upload', null, {\n      configPath: configPath\n    });\n    _this.uriProvidedManually = !!cfg.uri;\n    _this.uri = cfg.uri || _this.get('uri');\n    _this.numBytesWritten = 0;\n    _this.numRetries = 0;\n    var contentLength = cfg.metadata ? Number(cfg.metadata.contentLength) : NaN;\n    _this.contentLength = isNaN(contentLength) ? '*' : contentLength;\n\n    _this.once('writing', function () {\n      if (_this.uri) {\n        _this.continueUploading();\n      } else {\n        _this.createURI(function (err) {\n          if (err) {\n            return _this.destroy(err);\n          }\n\n          _this.startUploading();\n        });\n      }\n    });\n\n    return _this;\n  }\n\n  _createClass(Upload, [{\n    key: \"createURI\",\n    value: function createURI(callback) {\n      if (!callback) {\n        return this.createURIAsync();\n      }\n\n      this.createURIAsync().then(function (r) {\n        return callback(null, r);\n      }, callback);\n    }\n  }, {\n    key: \"createURIAsync\",\n    value: function () {\n      var _createURIAsync = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee() {\n        var metadata, reqOpts, resp, uri;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                metadata = this.metadata;\n                reqOpts = {\n                  method: 'POST',\n                  url: [this.baseURI, this.bucket, 'o'].join('/'),\n                  params: Object.assign({\n                    name: this.file,\n                    uploadType: 'resumable'\n                  }, this.params),\n                  data: metadata,\n                  headers: {}\n                };\n\n                if (metadata.contentLength) {\n                  reqOpts.headers['X-Upload-Content-Length'] = metadata.contentLength.toString();\n                }\n\n                if (metadata.contentType) {\n                  reqOpts.headers['X-Upload-Content-Type'] = metadata.contentType;\n                }\n\n                if (typeof this.generation !== 'undefined') {\n                  reqOpts.params.ifGenerationMatch = this.generation;\n                }\n\n                if (this.kmsKeyName) {\n                  reqOpts.params.kmsKeyName = this.kmsKeyName;\n                }\n\n                if (this.predefinedAcl) {\n                  reqOpts.params.predefinedAcl = this.predefinedAcl;\n                }\n\n                if (this.origin) {\n                  reqOpts.headers.Origin = this.origin;\n                }\n\n                _context.next = 10;\n                return this.makeRequest(reqOpts);\n\n              case 10:\n                resp = _context.sent;\n                uri = resp.headers.location;\n                this.uri = uri;\n                this.set({\n                  uri: uri\n                });\n                this.offset = 0;\n                return _context.abrupt(\"return\", uri);\n\n              case 16:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function createURIAsync() {\n        return _createURIAsync.apply(this, arguments);\n      }\n\n      return createURIAsync;\n    }()\n  }, {\n    key: \"continueUploading\",\n    value: function () {\n      var _continueUploading = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee2() {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!(typeof this.offset === 'number')) {\n                  _context2.next = 3;\n                  break;\n                }\n\n                this.startUploading();\n                return _context2.abrupt(\"return\");\n\n              case 3:\n                _context2.next = 5;\n                return this.getAndSetOffset();\n\n              case 5:\n                this.startUploading();\n\n              case 6:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function continueUploading() {\n        return _continueUploading.apply(this, arguments);\n      }\n\n      return continueUploading;\n    }()\n  }, {\n    key: \"startUploading\",\n    value: function () {\n      var _startUploading = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee3() {\n        var _this2 = this;\n\n        var bufferStream, offsetStream, delayStream, requestStreamEmbeddedStream, reqOpts;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                // The buffer stream allows us to keep chunks in memory\n                // until we are sure we can successfully resume the upload.\n                bufferStream = this.bufferStream || new stream_1.PassThrough();\n                this.bufferStream = bufferStream; // The offset stream allows us to analyze each incoming\n                // chunk to analyze it against what the upstream API already\n                // has stored for this upload.\n\n                offsetStream = this.offsetStream = new stream_1.Transform({\n                  transform: this.onChunk.bind(this)\n                }); // The delay stream gives us a chance to catch the response\n                // from the API request before we signal to the user that\n                // the upload was successful.\n\n                delayStream = new stream_1.PassThrough(); // The request library (authClient.request()) requires the\n                // stream to be sent within the request options.\n\n                requestStreamEmbeddedStream = new stream_1.PassThrough();\n                delayStream.on('prefinish', function () {\n                  // Pause the stream from finishing so we can process the\n                  // response from the API.\n                  _this2.cork();\n                }); // Process the API response to look for errors that came in\n                // the response body.\n\n                this.on('response', function (resp) {\n                  if (resp.data.error) {\n                    _this2.destroy(resp.data.error);\n\n                    return;\n                  }\n\n                  if (resp.status < 200 || resp.status > 299) {\n                    _this2.destroy(new Error('Upload failed'));\n\n                    return;\n                  }\n\n                  if (resp && resp.data) {\n                    resp.data.size = Number(resp.data.size);\n                  }\n\n                  _this2.emit('metadata', resp.data);\n\n                  _this2.deleteConfig(); // Allow the stream to continue naturally so the user's\n                  // \"finish\" event fires.\n\n\n                  _this2.uncork();\n                });\n                this.setPipeline(bufferStream, offsetStream, delayStream);\n                this.pipe(requestStreamEmbeddedStream);\n                this.once('restart', function () {\n                  // The upload is being re-attempted. Disconnect the request\n                  // stream, so it won't receive more data.\n                  _this2.unpipe(requestStreamEmbeddedStream);\n                });\n                reqOpts = {\n                  method: 'PUT',\n                  url: this.uri,\n                  headers: {\n                    'Content-Range': 'bytes ' + this.offset + '-*/' + this.contentLength\n                  },\n                  body: requestStreamEmbeddedStream\n                };\n                _context3.prev = 11;\n                _context3.next = 14;\n                return this.makeRequestStream(reqOpts);\n\n              case 14:\n                _context3.next = 19;\n                break;\n\n              case 16:\n                _context3.prev = 16;\n                _context3.t0 = _context3[\"catch\"](11);\n                this.destroy(_context3.t0);\n\n              case 19:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[11, 16]]);\n      }));\n\n      function startUploading() {\n        return _startUploading.apply(this, arguments);\n      }\n\n      return startUploading;\n    }()\n  }, {\n    key: \"onChunk\",\n    value: function onChunk(chunk, enc, next) {\n      var offset = this.offset;\n      var numBytesWritten = this.numBytesWritten;\n      this.emit('progress', {\n        bytesWritten: this.numBytesWritten,\n        contentLength: this.contentLength\n      }); // check if this is the same content uploaded previously. this caches a\n      // slice of the first chunk, then compares it with the first byte of\n      // incoming data\n\n      if (numBytesWritten === 0) {\n        var cachedFirstChunk = this.get('firstChunk');\n        var firstChunk = chunk.slice(0, 16).valueOf();\n\n        if (!cachedFirstChunk) {\n          // This is a new upload. Cache the first chunk.\n          this.set({\n            uri: this.uri,\n            firstChunk: firstChunk\n          });\n        } else {\n          // this continues an upload in progress. check if the bytes are the same\n          cachedFirstChunk = Buffer.from(cachedFirstChunk);\n          var nextChunk = Buffer.from(firstChunk);\n\n          if (Buffer.compare(cachedFirstChunk, nextChunk) !== 0) {\n            // this data is not the same. start a new upload\n            this.bufferStream.unshift(chunk);\n            this.bufferStream.unpipe(this.offsetStream);\n            this.restart();\n            return;\n          }\n        }\n      }\n\n      var length = chunk.length;\n      if (typeof chunk === 'string') length = Buffer.byteLength(chunk, enc);\n      if (numBytesWritten < offset) chunk = chunk.slice(offset - numBytesWritten);\n      this.numBytesWritten += length; // only push data from the byte after the one we left off on\n\n      next(undefined, this.numBytesWritten > offset ? chunk : undefined);\n    }\n  }, {\n    key: \"getAndSetOffset\",\n    value: function () {\n      var _getAndSetOffset = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee4() {\n        var opts, resp, range, _resp;\n\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                opts = {\n                  method: 'PUT',\n                  url: this.uri,\n                  headers: {\n                    'Content-Length': 0,\n                    'Content-Range': 'bytes */*'\n                  }\n                };\n                _context4.prev = 1;\n                _context4.next = 4;\n                return this.makeRequest(opts);\n\n              case 4:\n                resp = _context4.sent;\n\n                if (!(resp.status === RESUMABLE_INCOMPLETE_STATUS_CODE)) {\n                  _context4.next = 10;\n                  break;\n                }\n\n                if (!resp.headers.range) {\n                  _context4.next = 10;\n                  break;\n                }\n\n                range = resp.headers.range;\n                this.offset = Number(range.split('-')[1]) + 1;\n                return _context4.abrupt(\"return\");\n\n              case 10:\n                this.offset = 0;\n                _context4.next = 23;\n                break;\n\n              case 13:\n                _context4.prev = 13;\n                _context4.t0 = _context4[\"catch\"](1);\n                _resp = _context4.t0.response; // we don't return a 404 to the user if they provided the resumable\n                // URI. if we're just using the configstore file to tell us that this\n                // file exists, and it turns out that it doesn't (the 404), that's\n                // probably stale config data.\n\n                if (!(_resp && _resp.status === 404 && !this.uriProvidedManually)) {\n                  _context4.next = 19;\n                  break;\n                }\n\n                this.restart();\n                return _context4.abrupt(\"return\");\n\n              case 19:\n                if (!(_resp && _resp.status === TERMINATED_UPLOAD_STATUS_CODE)) {\n                  _context4.next = 22;\n                  break;\n                }\n\n                this.restart();\n                return _context4.abrupt(\"return\");\n\n              case 22:\n                this.destroy(_context4.t0);\n\n              case 23:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this, [[1, 13]]);\n      }));\n\n      function getAndSetOffset() {\n        return _getAndSetOffset.apply(this, arguments);\n      }\n\n      return getAndSetOffset;\n    }()\n  }, {\n    key: \"makeRequest\",\n    value: function () {\n      var _makeRequest = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee5(reqOpts) {\n        var res;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                if (this.encryption) {\n                  reqOpts.headers = reqOpts.headers || {};\n                  reqOpts.headers['x-goog-encryption-algorithm'] = 'AES256';\n                  reqOpts.headers['x-goog-encryption-key'] = this.encryption.key.toString();\n                  reqOpts.headers['x-goog-encryption-key-sha256'] = this.encryption.hash.toString();\n                }\n\n                if (this.userProject) {\n                  reqOpts.params = reqOpts.params || {};\n                  reqOpts.params.userProject = this.userProject;\n                } // Let gaxios know we will handle a 308 error code ourselves.\n\n\n                reqOpts.validateStatus = function (status) {\n                  return status >= 200 && status < 300 || status === RESUMABLE_INCOMPLETE_STATUS_CODE;\n                };\n\n                _context5.next = 5;\n                return this.authClient.request(reqOpts);\n\n              case 5:\n                res = _context5.sent;\n\n                if (!(res.data && res.data.error)) {\n                  _context5.next = 8;\n                  break;\n                }\n\n                throw res.data.error;\n\n              case 8:\n                return _context5.abrupt(\"return\", res);\n\n              case 9:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function makeRequest(_x) {\n        return _makeRequest.apply(this, arguments);\n      }\n\n      return makeRequest;\n    }()\n  }, {\n    key: \"makeRequestStream\",\n    value: function () {\n      var _makeRequestStream = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee6(reqOpts) {\n        var controller, res;\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                controller = new abort_controller_1.default();\n                this.once('error', function () {\n                  return controller.abort();\n                });\n\n                if (this.userProject) {\n                  reqOpts.params = reqOpts.params || {};\n                  reqOpts.params.userProject = this.userProject;\n                }\n\n                reqOpts.signal = controller.signal;\n\n                reqOpts.validateStatus = function () {\n                  return true;\n                };\n\n                _context6.next = 7;\n                return this.authClient.request(reqOpts);\n\n              case 7:\n                res = _context6.sent;\n                this.onResponse(res);\n                return _context6.abrupt(\"return\", res);\n\n              case 10:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function makeRequestStream(_x2) {\n        return _makeRequestStream.apply(this, arguments);\n      }\n\n      return makeRequestStream;\n    }()\n  }, {\n    key: \"restart\",\n    value: function restart() {\n      var _this3 = this;\n\n      this.emit('restart');\n      this.numBytesWritten = 0;\n      this.deleteConfig();\n      this.createURI(function (err) {\n        if (err) {\n          return _this3.destroy(err);\n        }\n\n        _this3.startUploading();\n      });\n    }\n  }, {\n    key: \"get\",\n    value: function get(prop) {\n      var store = this.configStore.get(this.cacheKey);\n      return store && store[prop];\n    } // tslint:disable-next-line no-any\n\n  }, {\n    key: \"set\",\n    value: function set(props) {\n      this.configStore.set(this.cacheKey, props);\n    }\n  }, {\n    key: \"deleteConfig\",\n    value: function deleteConfig() {\n      this.configStore.delete(this.cacheKey);\n    }\n    /**\n     * @return {bool} is the request good?\n     */\n\n  }, {\n    key: \"onResponse\",\n    value: function onResponse(resp) {\n      if (resp.status === 404) {\n        if (this.numRetries < RETRY_LIMIT) {\n          this.numRetries++;\n          this.startUploading();\n        } else {\n          this.destroy(new Error('Retry limit exceeded - ' + resp.data));\n        }\n\n        return false;\n      }\n\n      if (resp.status > 499 && resp.status < 600) {\n        if (this.numRetries < RETRY_LIMIT) {\n          var randomMs = Math.round(Math.random() * 1000);\n          var waitTime = Math.pow(2, this.numRetries) * 1000 + randomMs;\n          this.numRetries++;\n          setTimeout(this.continueUploading.bind(this), waitTime);\n        } else {\n          this.destroy(new Error('Retry limit exceeded - ' + resp.data));\n        }\n\n        return false;\n      }\n\n      this.emit('response', resp);\n      return true;\n    }\n  }, {\n    key: \"baseURI\",\n    get: function get() {\n      return \"https://\".concat(this.apiEndpoint, \"/upload/storage/v1/b\");\n    }\n  }]);\n\n  return Upload;\n}(Pumpify);\n\nexports.Upload = Upload;\n\nfunction upload(cfg) {\n  return new Upload(cfg);\n}\n\nexports.upload = upload;\n\nfunction createURI(cfg, callback) {\n  var up = new Upload(cfg);\n\n  if (!callback) {\n    return up.createURI();\n  }\n\n  up.createURI().then(function (r) {\n    return callback(null, r);\n  }, callback);\n}\n\nexports.createURI = createURI;","map":null,"metadata":{},"sourceType":"script"}