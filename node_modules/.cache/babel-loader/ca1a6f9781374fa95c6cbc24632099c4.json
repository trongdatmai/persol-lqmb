{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nvar _regeneratorRuntime = require(\"/Users/maidat/Desktop/team-lq/persol-lqmb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/maidat/Desktop/team-lq/persol-lqmb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/maidat/Desktop/team-lq/persol-lqmb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/maidat/Desktop/team-lq/persol-lqmb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/Users/maidat/Desktop/team-lq/persol-lqmb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/Users/maidat/Desktop/team-lq/persol-lqmb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/maidat/Desktop/team-lq/persol-lqmb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _slicedToArray = require(\"/Users/maidat/Desktop/team-lq/persol-lqmb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar constants_1 = require(\"./constants\");\n\nvar filter_1 = require(\"./filter\");\n\nvar units = [['m', 1], ['S', 1000], ['M', 60 * 1000], ['H', 60 * 60 * 1000]];\n\nfunction getDeadline(deadline) {\n  var now = new Date().getTime();\n  var timeoutMs = Math.max(deadline - now, 0);\n\n  for (var _i = 0, _units = units; _i < _units.length; _i++) {\n    var _ref3 = _units[_i];\n\n    var _ref2 = _slicedToArray(_ref3, 2);\n\n    var unit = _ref2[0];\n    var factor = _ref2[1];\n    var amount = timeoutMs / factor;\n\n    if (amount < 1e8) {\n      return String(Math.ceil(amount)) + unit;\n    }\n  }\n\n  throw new Error('Deadline is too far in the future');\n}\n\nvar DeadlineFilter =\n/*#__PURE__*/\nfunction (_filter_1$BaseFilter) {\n  _inherits(DeadlineFilter, _filter_1$BaseFilter);\n\n  function DeadlineFilter(channel, callStream) {\n    var _this;\n\n    _classCallCheck(this, DeadlineFilter);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(DeadlineFilter).call(this));\n    _this.channel = channel;\n    _this.callStream = callStream;\n    _this.timer = null;\n    var callDeadline = callStream.getDeadline();\n\n    if (callDeadline instanceof Date) {\n      _this.deadline = callDeadline.getTime();\n    } else {\n      _this.deadline = callDeadline;\n    }\n\n    var now = new Date().getTime();\n    var timeout = _this.deadline - now;\n\n    if (timeout < 0) {\n      timeout = 0;\n    }\n\n    if (_this.deadline !== Infinity) {\n      _this.timer = setTimeout(function () {\n        callStream.cancelWithStatus(constants_1.Status.DEADLINE_EXCEEDED, 'Deadline exceeded');\n      }, timeout);\n      callStream.on('status', function () {\n        return clearTimeout(_this.timer);\n      });\n    }\n\n    return _this;\n  }\n\n  _createClass(DeadlineFilter, [{\n    key: \"sendMetadata\",\n    value: function () {\n      var _sendMetadata = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee(metadata) {\n        var finalMetadata, timeoutString;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!(this.deadline === Infinity)) {\n                  _context.next = 2;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", metadata);\n\n              case 2:\n                _context.next = 4;\n                return metadata;\n\n              case 4:\n                finalMetadata = _context.sent;\n                timeoutString = getDeadline(this.deadline);\n                finalMetadata.set('grpc-timeout', timeoutString);\n                return _context.abrupt(\"return\", finalMetadata);\n\n              case 8:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function sendMetadata(_x) {\n        return _sendMetadata.apply(this, arguments);\n      }\n\n      return sendMetadata;\n    }()\n  }]);\n\n  return DeadlineFilter;\n}(filter_1.BaseFilter);\n\nexports.DeadlineFilter = DeadlineFilter;\n\nvar DeadlineFilterFactory =\n/*#__PURE__*/\nfunction () {\n  function DeadlineFilterFactory(channel) {\n    _classCallCheck(this, DeadlineFilterFactory);\n\n    this.channel = channel;\n  }\n\n  _createClass(DeadlineFilterFactory, [{\n    key: \"createFilter\",\n    value: function createFilter(callStream) {\n      return new DeadlineFilter(this.channel, callStream);\n    }\n  }]);\n\n  return DeadlineFilterFactory;\n}();\n\nexports.DeadlineFilterFactory = DeadlineFilterFactory;","map":null,"metadata":{},"sourceType":"script"}