{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nvar _classCallCheck = require(\"/Users/maidat/Desktop/team-lq/persol-lqmb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/maidat/Desktop/team-lq/persol-lqmb/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar load_balancer_1 = require(\"./load-balancer\");\n\nvar channel_1 = require(\"./channel\");\n\nvar resolver_1 = require(\"./resolver\");\n\nvar picker_1 = require(\"./picker\");\n\nvar backoff_timeout_1 = require(\"./backoff-timeout\");\n\nvar constants_1 = require(\"./constants\");\n\nvar metadata_1 = require(\"./metadata\");\n\nvar logging = require(\"./logging\");\n\nvar constants_2 = require(\"./constants\");\n\nvar TRACER_NAME = 'resolving_load_balancer';\n\nfunction trace(text) {\n  logging.trace(constants_2.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\n\nvar DEFAULT_LOAD_BALANCER_NAME = 'pick_first';\n\nvar ResolvingLoadBalancer =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Wrapper class that behaves like a `LoadBalancer` and also handles name\n   * resolution internally.\n   * @param target The address of the backend to connect to.\n   * @param channelControlHelper `ChannelControlHelper` instance provided by\n   *     this load balancer's owner.\n   * @param defaultServiceConfig The default service configuration to be used\n   *     if none is provided by the name resolver. A `null` value indicates\n   *     that the default behavior should be the default unconfigured behavior.\n   *     In practice, that means using the \"pick first\" load balancer\n   *     implmentation\n   */\n  function ResolvingLoadBalancer(target, channelControlHelper, defaultServiceConfig) {\n    var _this = this;\n\n    _classCallCheck(this, ResolvingLoadBalancer);\n\n    this.target = target;\n    this.channelControlHelper = channelControlHelper;\n    this.defaultServiceConfig = defaultServiceConfig;\n    /**\n     * Current internal load balancer used for handling calls.\n     * Invariant: innerLoadBalancer === null => pendingReplacementLoadBalancer === null.\n     */\n\n    this.innerLoadBalancer = null;\n    /**\n     * The load balancer instance that will be used in place of the current\n     * `innerLoadBalancer` once either that load balancer loses its connection\n     * or this one establishes a connection. For use when a new name resolution\n     * result comes in with a different load balancing configuration, and the\n     * current `innerLoadBalancer` is still connected.\n     */\n\n    this.pendingReplacementLoadBalancer = null;\n    /**\n     * This resolving load balancer's current connectivity state.\n     */\n\n    this.currentState = channel_1.ConnectivityState.IDLE;\n    /**\n     * The service config object from the last successful resolution, if\n     * available. A value of undefined indicates that there has not yet\n     * been a successful resolution. A value of null indicates that the last\n     * successful resolution explicitly provided a null service config.\n     */\n\n    this.previousServiceConfig = undefined;\n    /**\n     * The most recently reported connectivity state of the `innerLoadBalancer`.\n     */\n\n    this.innerBalancerState = channel_1.ConnectivityState.IDLE;\n    this.innerBalancerPicker = new picker_1.UnavailablePicker();\n    /**\n     * The most recent reported state of the pendingReplacementLoadBalancer.\n     * Starts at IDLE for type simplicity. This should get updated as soon as the\n     * pendingReplacementLoadBalancer gets constructed.\n     */\n\n    this.replacementBalancerState = channel_1.ConnectivityState.IDLE;\n    /**\n     * The picker associated with the replacementBalancerState. Starts as an\n     * UnavailablePicker for type simplicity. This should get updated as soon as\n     * the pendingReplacementLoadBalancer gets constructed.\n     */\n\n    this.replacementBalancerPicker = new picker_1.UnavailablePicker();\n    /**\n     * Indicates whether we should attempt to resolve again after the backoff\n     * timer runs out.\n     */\n\n    this.continueResolving = false;\n    this.updateState(channel_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));\n    this.innerResolver = resolver_1.createResolver(target, {\n      onSuccessfulResolution: function onSuccessfulResolution(addressList, serviceConfig, serviceConfigError) {\n        var workingServiceConfig = null;\n        /* This first group of conditionals implements the algorithm described\n         * in https://github.com/grpc/proposal/blob/master/A21-service-config-error-handling.md\n         * in the section called \"Behavior on receiving a new gRPC Config\".\n         */\n\n        if (serviceConfig === null) {\n          // Step 4 and 5\n          if (serviceConfigError === null) {\n            // Step 5\n            _this.previousServiceConfig = serviceConfig;\n            workingServiceConfig = _this.defaultServiceConfig;\n          } else {\n            // Step 4\n            if (_this.previousServiceConfig === undefined) {\n              // Step 4.ii\n              if (_this.defaultServiceConfig === null) {\n                // Step 4.ii.b\n                _this.handleResolutionFailure(serviceConfigError);\n              } else {\n                // Step 4.ii.a\n                workingServiceConfig = _this.defaultServiceConfig;\n              }\n            } else {\n              // Step 4.i\n              workingServiceConfig = _this.previousServiceConfig;\n            }\n          }\n        } else {\n          // Step 3\n          workingServiceConfig = serviceConfig;\n          _this.previousServiceConfig = serviceConfig;\n        }\n\n        var loadBalancerName = null;\n        var loadBalancingConfig = null;\n\n        if (workingServiceConfig === null || workingServiceConfig.loadBalancingConfig.length === 0) {\n          loadBalancerName = DEFAULT_LOAD_BALANCER_NAME;\n        } else {\n          var _iteratorNormalCompletion = true;\n          var _didIteratorError = false;\n          var _iteratorError = undefined;\n\n          try {\n            for (var _iterator = workingServiceConfig.loadBalancingConfig[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n              var lbConfig = _step.value;\n\n              // Iterating through a oneof looking for whichever one is populated\n              for (var key in lbConfig) {\n                if (Object.prototype.hasOwnProperty.call(lbConfig, key)) {\n                  if (load_balancer_1.isLoadBalancerNameRegistered(key)) {\n                    loadBalancerName = key;\n                    loadBalancingConfig = lbConfig;\n                    break;\n                  }\n                }\n              }\n\n              if (loadBalancerName !== null) {\n                break;\n              }\n            }\n          } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion && _iterator.return != null) {\n                _iterator.return();\n              }\n            } finally {\n              if (_didIteratorError) {\n                throw _iteratorError;\n              }\n            }\n          }\n\n          if (loadBalancerName === null) {\n            // There were load balancing configs but none are supported. This counts as a resolution failure\n            _this.handleResolutionFailure({\n              code: constants_1.Status.UNAVAILABLE,\n              details: 'All load balancer options in service config are not compatible',\n              metadata: new metadata_1.Metadata()\n            });\n\n            return;\n          }\n        }\n\n        if (_this.innerLoadBalancer === null) {\n          _this.innerLoadBalancer = load_balancer_1.createLoadBalancer(loadBalancerName, _this.innerChannelControlHelper);\n\n          _this.innerLoadBalancer.updateAddressList(addressList, loadBalancingConfig);\n        } else if (_this.innerLoadBalancer.getTypeName() === loadBalancerName) {\n          _this.innerLoadBalancer.updateAddressList(addressList, loadBalancingConfig);\n        } else {\n          if (_this.pendingReplacementLoadBalancer === null || _this.pendingReplacementLoadBalancer.getTypeName() !== loadBalancerName) {\n            if (_this.pendingReplacementLoadBalancer !== null) {\n              _this.pendingReplacementLoadBalancer.destroy();\n            }\n\n            _this.pendingReplacementLoadBalancer = load_balancer_1.createLoadBalancer(loadBalancerName, _this.replacementChannelControlHelper);\n          }\n\n          _this.pendingReplacementLoadBalancer.updateAddressList(addressList, loadBalancingConfig);\n        }\n      },\n      onError: function onError(error) {\n        _this.handleResolutionFailure(error);\n      }\n    });\n    this.innerChannelControlHelper = {\n      createSubchannel: function createSubchannel(subchannelAddress, subchannelArgs) {\n        return _this.channelControlHelper.createSubchannel(subchannelAddress, subchannelArgs);\n      },\n      updateState: function updateState(connectivityState, picker) {\n        _this.innerBalancerState = connectivityState;\n\n        if (connectivityState === channel_1.ConnectivityState.IDLE) {\n          picker = new picker_1.QueuePicker(_this);\n        }\n\n        _this.innerBalancerPicker = picker;\n\n        if (connectivityState !== channel_1.ConnectivityState.READY && _this.pendingReplacementLoadBalancer !== null) {\n          _this.switchOverReplacementBalancer();\n        } else {\n          if (connectivityState === channel_1.ConnectivityState.IDLE) {\n            if (_this.innerLoadBalancer) {\n              _this.innerLoadBalancer.destroy();\n\n              _this.innerLoadBalancer = null;\n            }\n          }\n\n          _this.updateState(connectivityState, picker);\n        }\n      },\n      requestReresolution: function requestReresolution() {\n        if (_this.pendingReplacementLoadBalancer === null) {\n          /* If the backoffTimeout is running, we're still backing off from\n           * making resolve requests, so we shouldn't make another one here.\n           * In that case, the backoff timer callback will call\n           * updateResolution */\n          if (_this.backoffTimeout.isRunning()) {\n            _this.continueResolving = true;\n          } else {\n            _this.updateResolution();\n          }\n        }\n      }\n    };\n    this.replacementChannelControlHelper = {\n      createSubchannel: function createSubchannel(subchannelAddress, subchannelArgs) {\n        return _this.channelControlHelper.createSubchannel(subchannelAddress, subchannelArgs);\n      },\n      updateState: function updateState(connectivityState, picker) {\n        if (connectivityState === channel_1.ConnectivityState.IDLE) {\n          picker = new picker_1.QueuePicker(_this);\n        }\n\n        _this.replacementBalancerState = connectivityState;\n        _this.replacementBalancerPicker = picker;\n\n        if (connectivityState === channel_1.ConnectivityState.READY) {\n          _this.switchOverReplacementBalancer();\n        } else if (connectivityState === channel_1.ConnectivityState.IDLE) {\n          if (_this.pendingReplacementLoadBalancer) {\n            _this.pendingReplacementLoadBalancer.destroy();\n\n            _this.pendingReplacementLoadBalancer = null;\n          }\n        }\n      },\n      requestReresolution: function requestReresolution() {\n        /* If the backoffTimeout is running, we're still backing off from\n         * making resolve requests, so we shouldn't make another one here.\n         * In that case, the backoff timer callback will call\n         * updateResolution */\n        if (_this.backoffTimeout.isRunning()) {\n          _this.continueResolving = true;\n        } else {\n          _this.updateResolution();\n        }\n      }\n    };\n    this.backoffTimeout = new backoff_timeout_1.BackoffTimeout(function () {\n      if (_this.continueResolving) {\n        _this.updateResolution();\n\n        _this.continueResolving = false;\n      } else {\n        if (_this.innerLoadBalancer === null) {\n          _this.updateState(channel_1.ConnectivityState.IDLE, new picker_1.QueuePicker(_this));\n        } else {\n          _this.updateState(_this.innerBalancerState, _this.innerBalancerPicker);\n        }\n      }\n    });\n  }\n\n  _createClass(ResolvingLoadBalancer, [{\n    key: \"updateResolution\",\n    value: function updateResolution() {\n      this.innerResolver.updateResolution();\n\n      if (this.innerLoadBalancer === null || this.innerBalancerState === channel_1.ConnectivityState.IDLE) {\n        this.updateState(channel_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));\n      }\n    }\n  }, {\n    key: \"updateState\",\n    value: function updateState(connectivitystate, picker) {\n      trace(this.target + ' ' + channel_1.ConnectivityState[this.currentState] + ' -> ' + channel_1.ConnectivityState[connectivitystate]);\n      this.currentState = connectivitystate;\n      this.channelControlHelper.updateState(connectivitystate, picker);\n    }\n    /**\n     * Stop using the current innerLoadBalancer and replace it with the\n     * pendingReplacementLoadBalancer. Must only be called if both of\n     * those are currently not null.\n     */\n\n  }, {\n    key: \"switchOverReplacementBalancer\",\n    value: function switchOverReplacementBalancer() {\n      this.innerLoadBalancer.destroy();\n      this.innerLoadBalancer = this.pendingReplacementLoadBalancer;\n      this.innerLoadBalancer.replaceChannelControlHelper(this.innerChannelControlHelper);\n      this.pendingReplacementLoadBalancer = null;\n      this.innerBalancerState = this.replacementBalancerState;\n      this.innerBalancerPicker = this.replacementBalancerPicker;\n      this.updateState(this.replacementBalancerState, this.replacementBalancerPicker);\n    }\n  }, {\n    key: \"handleResolutionFailure\",\n    value: function handleResolutionFailure(error) {\n      if (this.innerLoadBalancer === null || this.innerBalancerState === channel_1.ConnectivityState.IDLE) {\n        this.updateState(channel_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker(error));\n      }\n\n      this.backoffTimeout.runOnce();\n    }\n  }, {\n    key: \"exitIdle\",\n    value: function exitIdle() {\n      if (this.innerLoadBalancer !== null) {\n        this.innerLoadBalancer.exitIdle();\n      }\n\n      if (this.currentState === channel_1.ConnectivityState.IDLE) {\n        if (this.backoffTimeout.isRunning()) {\n          this.continueResolving = true;\n        } else {\n          this.updateResolution();\n        }\n\n        this.updateState(channel_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));\n      }\n    }\n  }, {\n    key: \"updateAddressList\",\n    value: function updateAddressList(addressList, lbConfig) {\n      throw new Error('updateAddressList not supported on ResolvingLoadBalancer');\n    }\n  }, {\n    key: \"resetBackoff\",\n    value: function resetBackoff() {\n      this.backoffTimeout.reset();\n\n      if (this.innerLoadBalancer !== null) {\n        this.innerLoadBalancer.resetBackoff();\n      }\n\n      if (this.pendingReplacementLoadBalancer !== null) {\n        this.pendingReplacementLoadBalancer.resetBackoff();\n      }\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      if (this.innerLoadBalancer !== null) {\n        this.innerLoadBalancer.destroy();\n        this.innerLoadBalancer = null;\n      }\n\n      if (this.pendingReplacementLoadBalancer !== null) {\n        this.pendingReplacementLoadBalancer.destroy();\n        this.pendingReplacementLoadBalancer = null;\n      }\n\n      this.updateState(channel_1.ConnectivityState.SHUTDOWN, new picker_1.UnavailablePicker());\n    }\n  }, {\n    key: \"getTypeName\",\n    value: function getTypeName() {\n      return 'resolving_load_balancer';\n    }\n  }, {\n    key: \"replaceChannelControlHelper\",\n    value: function replaceChannelControlHelper(channelControlHelper) {\n      this.channelControlHelper = channelControlHelper;\n    }\n  }]);\n\n  return ResolvingLoadBalancer;\n}();\n\nexports.ResolvingLoadBalancer = ResolvingLoadBalancer;","map":null,"metadata":{},"sourceType":"script"}