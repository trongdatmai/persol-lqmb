{"ast":null,"code":"\"use strict\";\n/*!\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar node_fetch_1 = require(\"node-fetch\");\n\nvar stream_1 = require(\"stream\");\n\nvar uuid = require(\"uuid\");\n\nvar agents_1 = require(\"./agents\");\n\nvar streamEvents = require('stream-events');\n\nvar RequestError =\n/** @class */\nfunction (_super) {\n  __extends(RequestError, _super);\n\n  function RequestError() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  return RequestError;\n}(Error);\n\nexports.RequestError = RequestError;\n/**\n * Convert options from Request to Fetch format\n * @private\n * @param reqOpts Request options\n */\n\nfunction requestToFetchOptions(reqOpts) {\n  var options = __assign(__assign({\n    method: reqOpts.method || 'GET'\n  }, reqOpts.timeout && {\n    timeout: reqOpts.timeout\n  }), typeof reqOpts.gzip === 'boolean' && {\n    compress: reqOpts.gzip\n  });\n\n  if (typeof reqOpts.json === 'object') {\n    // Add Content-type: application/json header\n    reqOpts.headers = reqOpts.headers || {};\n    reqOpts.headers['Content-Type'] = 'application/json'; // Set body to JSON representation of value\n\n    options.body = JSON.stringify(reqOpts.json);\n  } else {\n    if (typeof reqOpts.body !== 'string') {\n      options.body = JSON.stringify(reqOpts.body);\n    } else {\n      options.body = reqOpts.body;\n    }\n  } // tslint:disable-next-line no-any\n\n\n  options.headers = reqOpts.headers;\n  var uri = reqOpts.uri || reqOpts.url;\n\n  if (reqOpts.useQuerystring === true || typeof reqOpts.qs === 'object') {\n    var qs = require('querystring');\n\n    var params = qs.stringify(reqOpts.qs);\n    uri = uri + '?' + params;\n  }\n\n  options.agent = agents_1.getAgent(uri, reqOpts);\n  return {\n    uri: uri,\n    options: options\n  };\n}\n/**\n * Convert a response from `fetch` to `request` format.\n * @private\n * @param opts The `request` options used to create the request.\n * @param res The Fetch response\n * @returns A `request` response object\n */\n\n\nfunction fetchToRequestResponse(opts, res) {\n  var request = {};\n  request.agent = opts.agent || false;\n  request.headers = opts.headers || {};\n  request.href = res.url; // headers need to be converted from a map to an obj\n\n  var resHeaders = {};\n  res.headers.forEach(function (value, key) {\n    return resHeaders[key] = value;\n  });\n  var response = Object.assign(res.body, {\n    statusCode: res.status,\n    statusMessage: res.statusText,\n    request: request,\n    body: res.body,\n    headers: resHeaders,\n    toJSON: function toJSON() {\n      return {\n        headers: resHeaders\n      };\n    }\n  });\n  return response;\n}\n/**\n * Create POST body from two parts as multipart/related content-type\n * @private\n * @param boundary\n * @param multipart\n */\n\n\nfunction createMultipartStream(boundary, multipart) {\n  var finale = \"--\" + boundary + \"--\";\n  var stream = new stream_1.PassThrough();\n\n  for (var _i = 0, multipart_1 = multipart; _i < multipart_1.length; _i++) {\n    var part = multipart_1[_i];\n    var preamble = \"--\" + boundary + \"\\r\\nContent-Type: \" + part['Content-Type'] + \"\\r\\n\\r\\n\";\n    stream.write(preamble);\n\n    if (typeof part.body === 'string') {\n      stream.write(part.body);\n      stream.write('\\r\\n');\n    } else {\n      part.body.pipe(stream, {\n        end: false\n      });\n      part.body.on('end', function () {\n        stream.write('\\r\\n');\n        stream.write(finale);\n        stream.end();\n      });\n    }\n  }\n\n  return stream;\n}\n\nfunction teenyRequest(reqOpts, callback) {\n  var _a = requestToFetchOptions(reqOpts),\n      uri = _a.uri,\n      options = _a.options;\n\n  var multipart = reqOpts.multipart;\n\n  if (reqOpts.multipart && multipart.length === 2) {\n    if (!callback) {\n      console.error('multipart without callback not implemented.');\n      return;\n    }\n\n    var boundary = uuid.v4();\n    options.headers['Content-Type'] = \"multipart/related; boundary=\" + boundary;\n    options.body = createMultipartStream(boundary, multipart); // Multipart upload\n\n    node_fetch_1.default(uri, options).then(function (res) {\n      var header = res.headers.get('content-type');\n      var response = fetchToRequestResponse(options, res);\n      var body = response.body;\n\n      if (header === 'application/json' || header === 'application/json; charset=utf-8') {\n        res.json().then(function (json) {\n          response.body = json;\n          callback(null, response, json);\n        }, function (err) {\n          callback(err, response, body);\n        });\n        return;\n      }\n\n      res.text().then(function (text) {\n        response.body = text;\n        callback(null, response, text);\n      }, function (err) {\n        callback(err, response, body);\n      });\n    }, function (err) {\n      callback(err, null, null);\n    });\n    return;\n  }\n\n  if (callback === undefined) {\n    // Stream mode\n    var requestStream_1 = streamEvents(new stream_1.PassThrough()); // tslint:disable-next-line no-any\n\n    var responseStream_1;\n    requestStream_1.once('reading', function () {\n      if (responseStream_1) {\n        responseStream_1.pipe(requestStream_1);\n      } else {\n        requestStream_1.once('response', function () {\n          responseStream_1.pipe(requestStream_1);\n        });\n      }\n    });\n    options.compress = false;\n    node_fetch_1.default(uri, options).then(function (res) {\n      responseStream_1 = res.body;\n      responseStream_1.on('error', function (err) {\n        requestStream_1.emit('error', err);\n      });\n      var response = fetchToRequestResponse(options, res);\n      requestStream_1.emit('response', response);\n    }, function (err) {\n      requestStream_1.emit('error', err);\n    }); // fetch doesn't supply the raw HTTP stream, instead it\n    // returns a PassThrough piped from the HTTP response\n    // stream.\n\n    return requestStream_1;\n  } // GET or POST with callback\n\n\n  node_fetch_1.default(uri, options).then(function (res) {\n    var header = res.headers.get('content-type');\n    var response = fetchToRequestResponse(options, res);\n    var body = response.body;\n\n    if (header === 'application/json' || header === 'application/json; charset=utf-8') {\n      if (response.statusCode === 204) {\n        // Probably a DELETE\n        callback(null, response, body);\n        return;\n      }\n\n      res.json().then(function (json) {\n        response.body = json;\n        callback(null, response, json);\n      }, function (err) {\n        callback(err, response, body);\n      });\n      return;\n    }\n\n    res.text().then(function (text) {\n      var response = fetchToRequestResponse(options, res);\n      response.body = text;\n      callback(null, response, text);\n    }, function (err) {\n      callback(err, response, body);\n    });\n  }, function (err) {\n    callback(err, null, null);\n  });\n  return;\n}\n\nexports.teenyRequest = teenyRequest;\n\nteenyRequest.defaults = function (defaults) {\n  return function (reqOpts, callback) {\n    var opts = __assign(__assign({}, defaults), reqOpts);\n\n    if (callback === undefined) {\n      return teenyRequest(opts);\n    }\n\n    teenyRequest(opts, callback);\n  };\n};","map":null,"metadata":{},"sourceType":"script"}